<!doctype html><html lang="en">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport">
  <title>D1144R0: Object relocation in terms of move plus destroy</title>
<style data-fill-with="stylesheet">/******************************************************************************
 *                   Style sheet for the W3C specifications                   *
 *
 * Special classes handled by this style sheet include:
 *
 * Indices
 *   - .toc for the Table of Contents (<ol class="toc">)
 *     + <span class="secno"> for the section numbers
 *   - #toc for the Table of Contents (<nav id="toc">)
 *   - ul.index for Indices (<a href="#ref">term</a><span>, in §N.M</span>)
 *   - table.index for Index Tables (e.g. for properties or elements)
 *
 * Structural Markup
 *   - table.data for general data tables
 *     -> use 'scope' attribute, <colgroup>, <thead>, and <tbody> for best results !
 *     -> use <table class='complex data'> for extra-complex tables
 *     -> use <td class='long'> for paragraph-length cell content
 *     -> use <td class='pre'> when manual line breaks/indentation would help readability
 *   - dl.switch for switch statements
 *   - ol.algorithm for algorithms (helps to visualize nesting)
 *   - .figure and .caption (HTML4) and figure and figcaption (HTML5)
 *     -> .sidefigure for right-floated figures
 *   - ins/del
 *
 * Code
 *   - pre and code
 *
 * Special Sections
 *   - .note       for informative notes             (div, p, span, aside, details)
 *   - .example    for informative examples          (div, p, pre, span)
 *   - .issue      for issues                        (div, p, span)
 *   - .assertion  for assertions                    (div, p, span)
 *   - .advisement for loud normative statements     (div, p, strong)
 *   - .annoying-warning for spec obsoletion notices (div, aside, details)
 *
 * Definition Boxes
 *   - pre.def   for WebIDL definitions
 *   - table.def for tables that define other entities (e.g. CSS properties)
 *   - dl.def    for definition lists that define other entitles (e.g. HTML elements)
 *
 * Numbering
 *   - .secno for section numbers in .toc and headings (<span class='secno'>3.2</span>)
 *   - .marker for source-inserted example/figure/issue numbers (<span class='marker'>Issue 4</span>)
 *   - ::before styled for CSS-generated issue/example/figure numbers:
 *     -> Documents wishing to use this only need to add
 *        figcaption::before,
 *        .caption::before { content: "Figure "  counter(figure) " ";  }
 *        .example::before { content: "Example " counter(example) " "; }
 *        .issue::before   { content: "Issue "   counter(issue) " ";   }
 *
 * Header Stuff (ignore, just don't conflict with these classes)
 *   - .head for the header
 *   - .copyright for the copyright
 *
 * Miscellaneous
 *   - .overlarge for things that should be as wide as possible, even if
 *     that overflows the body text area. This can be used on an item or
 *     on its container, depending on the effect desired.
 *     Note that this styling basically doesn't help at all when printing,
 *     since A4 paper isn't much wider than the max-width here.
 *     It's better to design things to fit into a narrower measure if possible.
 *   - js-added ToC jump links (see fixup.js)
 *
 ******************************************************************************/

/******************************************************************************/
/*                                   Body                                     */
/******************************************************************************/

	body {
		counter-reset: example figure issue;

		/* Layout */
		max-width: 50em;               /* limit line length to 50em for readability   */
		margin: 0 auto;                /* center text within page                     */
		padding: 1.6em 1.5em 2em 50px; /* assume 16px font size for downlevel clients */
		padding: 1.6em 1.5em 2em calc(26px + 1.5em); /* leave space for status flag     */

		/* Typography */
		line-height: 1.5;
		font-family: sans-serif;
		widows: 2;
		orphans: 2;
		word-wrap: break-word;
		overflow-wrap: break-word;
		hyphens: auto;

		/* Colors */
		color: black;
		background: white top left fixed no-repeat;
		background-size: 25px auto;
	}


/******************************************************************************/
/*                         Front Matter & Navigation                          */
/******************************************************************************/

/** Header ********************************************************************/

	div.head { margin-bottom: 1em }
	div.head hr { border-style: solid; }

	div.head h1 {
		font-weight: bold;
		margin: 0 0 .1em;
		font-size: 220%;
	}

	div.head h2 { margin-bottom: 1.5em;}

/** W3C Logo ******************************************************************/

	.head .logo {
		float: right;
		margin: 0.4rem 0 0.2rem .4rem;
	}

	.head img[src*="logos/W3C"] {
		display: block;
		border: solid #1a5e9a;
		border-width: .65rem .7rem .6rem;
		border-radius: .4rem;
		background: #1a5e9a;
		color: white;
		font-weight: bold;
	}

	.head a:hover > img[src*="logos/W3C"],
	.head a:focus > img[src*="logos/W3C"] {
		opacity: .8;
	}

	.head a:active > img[src*="logos/W3C"] {
		background: #c00;
		border-color: #c00;
	}

	/* see also additional rules in Link Styling section */

/** Copyright *****************************************************************/

	p.copyright,
	p.copyright small { font-size: small }

/** Back to Top / ToC Toggle **************************************************/

	@media print {
		#toc-nav {
			display: none;
		}
	}
	@media not print {
		#toc-nav {
			position: fixed;
			z-index: 2;
			bottom: 0; left: 0;
			margin: 0;
			min-width: 1.33em;
			border-top-right-radius: 2rem;
			box-shadow: 0 0 2px;
			font-size: 1.5em;
			color: black;
		}
		#toc-nav > a {
			display: block;
			white-space: nowrap;

			height: 1.33em;
			padding: .1em 0.3em;
			margin: 0;

			background: white;
			box-shadow: 0 0 2px;
			border: none;
			border-top-right-radius: 1.33em;
			background: white;
		}
		#toc-nav > #toc-jump {
			padding-bottom: 2em;
			margin-bottom: -1.9em;
		}

		#toc-nav > a:hover,
		#toc-nav > a:focus {
			background: #f8f8f8;
		}
		#toc-nav > a:not(:hover):not(:focus) {
			color: #707070;
		}

		/* statusbar gets in the way on keyboard focus; remove once browsers fix */
		#toc-nav > a[href="#toc"]:not(:hover):focus:last-child {
			padding-bottom: 1.5rem;
		}

		#toc-nav:not(:hover) > a:not(:focus) > span + span {
			/* Ideally this uses :focus-within on #toc-nav */
			display: none;
		}
		#toc-nav > a > span + span {
			padding-right: 0.2em;
		}

		#toc-toggle-inline {
			vertical-align: 0.05em;
			font-size: 80%;
			color: gray;
			color: hsla(203,20%,40%,.7);
			border-style: none;
			background: transparent;
			position: relative;
		}
		#toc-toggle-inline:hover:not(:active),
		#toc-toggle-inline:focus:not(:active) {
			text-shadow: 1px 1px silver;
			top: -1px;
			left: -1px;
		}

		#toc-nav :active {
			color: #C00;
		}
	}

/** ToC Sidebar ***************************************************************/

	/* Floating sidebar */
	@media screen {
		body.toc-sidebar #toc {
			position: fixed;
			top: 0; bottom: 0;
			left: 0;
			width: 23.5em;
			max-width: 80%;
			max-width: calc(100% - 2em - 26px);
			overflow: auto;
			padding: 0 1em;
			padding-left: 42px;
			padding-left: calc(1em + 26px);
			background: inherit;
			background-color: #f7f8f9;
			z-index: 1;
			box-shadow: -.1em 0 .25em rgba(0,0,0,.1) inset;
		}
		body.toc-sidebar #toc h2 {
			margin-top: .8rem;
			font-variant: small-caps;
			font-variant: all-small-caps;
			text-transform: lowercase;
			font-weight: bold;
			color: gray;
			color: hsla(203,20%,40%,.7);
		}
		body.toc-sidebar #toc-jump:not(:focus) {
			width: 0;
			height: 0;
			padding: 0;
			position: absolute;
			overflow: hidden;
		}
	}
	/* Hide main scroller when only the ToC is visible anyway */
	@media screen and (max-width: 28em) {
		body.toc-sidebar {
			overflow: hidden;
		}
	}

	/* Sidebar with its own space */
	@media screen and (min-width: 78em) {
		body:not(.toc-inline) #toc {
			position: fixed;
			top: 0; bottom: 0;
			left: 0;
			width: 23.5em;
			overflow: auto;
			padding: 0 1em;
			padding-left: 42px;
			padding-left: calc(1em + 26px);
			background: inherit;
			background-color: #f7f8f9;
			z-index: 1;
			box-shadow: -.1em 0 .25em rgba(0,0,0,.1) inset;
		}
		body:not(.toc-inline) #toc h2 {
			margin-top: .8rem;
			font-variant: small-caps;
			font-variant: all-small-caps;
			text-transform: lowercase;
			font-weight: bold;
			color: gray;
			color: hsla(203,20%,40%,.7);
		}

		body:not(.toc-inline) {
			padding-left: 29em;
		}
		/* See also Overflow section at the bottom */

		body:not(.toc-inline) #toc-jump:not(:focus) {
			width: 0;
			height: 0;
			padding: 0;
			position: absolute;
			overflow: hidden;
		}
	}
	@media screen and (min-width: 90em) {
		body:not(.toc-inline) {
			margin: 0 4em;
		}
	}

/******************************************************************************/
/*                                Sectioning                                  */
/******************************************************************************/

/** Headings ******************************************************************/

	h1, h2, h3, h4, h5, h6, dt {
		page-break-after: avoid;
		page-break-inside: avoid;
		font: 100% sans-serif;   /* Reset all font styling to clear out UA styles */
		font-family: inherit;    /* Inherit the font family. */
		line-height: 1.2;        /* Keep wrapped headings compact */
		hyphens: manual;         /* Hyphenated headings look weird */
	}

	h2, h3, h4, h5, h6 {
		margin-top: 3rem;
	}

	h1, h2, h3 {
		color: #005A9C;
		background: transparent;
	}

	h1 { font-size: 170%; }
	h2 { font-size: 140%; }
	h3 { font-size: 120%; }
	h4 { font-weight: bold; }
	h5 { font-style: italic; }
	h6 { font-variant: small-caps; }
	dt { font-weight: bold; }

/** Subheadings ***************************************************************/

	h1 + h2,
	#subtitle {
		/* #subtitle is a subtitle in an H2 under the H1 */
		margin-top: 0;
	}
	h2 + h3,
	h3 + h4,
	h4 + h5,
	h5 + h6 {
		margin-top: 1.2em; /* = 1 x line-height */
	}

/** Section divider ***********************************************************/

	:not(.head) > hr {
		font-size: 1.5em;
		text-align: center;
		margin: 1em auto;
		height: auto;
		border: transparent solid 0;
		background: transparent;
	}
	:not(.head) > hr::before {
		content: "\2727\2003\2003\2727\2003\2003\2727";
	}

/******************************************************************************/
/*                            Paragraphs and Lists                            */
/******************************************************************************/

	p {
		margin: 1em 0;
	}

	dd > p:first-child,
	li > p:first-child {
		margin-top: 0;
	}

	ul, ol {
		margin-left: 0;
		padding-left: 2em;
	}

	li {
		margin: 0.25em 0 0.5em;
		padding: 0;
	}

	dl dd {
		margin: 0 0 .5em 2em;
	}

	.head dd + dd { /* compact for header */
		margin-top: -.5em;
	}

	/* Style for algorithms */
	ol.algorithm ol:not(.algorithm),
	.algorithm > ol ol:not(.algorithm) {
	 border-left: 0.5em solid #DEF;
	}

	/* Put nice boxes around each algorithm. */
	[data-algorithm]:not(.heading) {
	  padding: .5em;
	  border: thin solid #ddd; border-radius: .5em;
	  margin: .5em calc(-0.5em - 1px);
	}
	[data-algorithm]:not(.heading) > :first-child {
	  margin-top: 0;
	}
	[data-algorithm]:not(.heading) > :last-child {
	  margin-bottom: 0;
	}

	/* Style for switch/case <dl>s */
	dl.switch > dd > ol.only,
	dl.switch > dd > .only > ol {
	 margin-left: 0;
	}
	dl.switch > dd > ol.algorithm,
	dl.switch > dd > .algorithm > ol {
	 margin-left: -2em;
	}
	dl.switch {
	 padding-left: 2em;
	}
	dl.switch > dt {
	 text-indent: -1.5em;
	 margin-top: 1em;
	}
	dl.switch > dt + dt {
	 margin-top: 0;
	}
	dl.switch > dt::before {
	 content: '\21AA';
	 padding: 0 0.5em 0 0;
	 display: inline-block;
	 width: 1em;
	 text-align: right;
	 line-height: 0.5em;
	}

/** Terminology Markup ********************************************************/


/******************************************************************************/
/*                                 Inline Markup                              */
/******************************************************************************/

/** Terminology Markup ********************************************************/
	dfn   { /* Defining instance */
		font-weight: bolder;
	}
	a > i { /* Instance of term */
		font-style: normal;
	}
	dt dfn code, code.idl {
		font-size: medium;
	}
	dfn var {
		font-style: normal;
	}

/** Change Marking ************************************************************/

	del { color: red;  text-decoration: line-through; }
	ins { color: #080; text-decoration: underline;    }

/** Miscellaneous improvements to inline formatting ***************************/

	sup {
		vertical-align: super;
		font-size: 80%
	}

/******************************************************************************/
/*                                    Code                                    */
/******************************************************************************/

/** General monospace/pre rules ***********************************************/

	pre, code, samp {
		font-family: Menlo, Consolas, "DejaVu Sans Mono", Monaco, monospace;
		font-size: .9em;
		page-break-inside: avoid;
		hyphens: none;
		text-transform: none;
	}
	pre code,
	code code {
		font-size: 100%;
	}

	pre {
		margin-top: 1em;
		margin-bottom: 1em;
		overflow: auto;
	}

/** Inline Code fragments *****************************************************/

  /* Do something nice. */

/******************************************************************************/
/*                                    Links                                   */
/******************************************************************************/

/** General Hyperlinks ********************************************************/

	/* We hyperlink a lot, so make it less intrusive */
	a[href] {
		color: #034575;
		text-decoration: none;
		border-bottom: 1px solid #707070;
		/* Need a bit of extending for it to look okay */
		padding: 0 1px 0;
		margin: 0 -1px 0;
	}
	a:visited {
		border-bottom-color: #BBB;
	}

	/* Use distinguishing colors when user is interacting with the link */
	a[href]:focus,
	a[href]:hover {
		background: #f8f8f8;
		background: rgba(75%, 75%, 75%, .25);
		border-bottom-width: 3px;
		margin-bottom: -2px;
	}
	a[href]:active {
		color: #C00;
		border-color: #C00;
	}

	/* Backout above styling for W3C logo */
	.head .logo,
	.head .logo a {
		border: none;
		text-decoration: none;
		background: transparent;
	}

/******************************************************************************/
/*                                    Images                                  */
/******************************************************************************/

	img {
		border-style: none;
	}

	/* For autogen numbers, add
	   .caption::before, figcaption::before { content: "Figure " counter(figure) ". "; }
	*/

	figure, .figure, .sidefigure {
		page-break-inside: avoid;
		text-align: center;
		margin: 2.5em 0;
	}
	.figure img,    .sidefigure img,    figure img,
	.figure object, .sidefigure object, figure object {
		max-width: 100%;
		margin: auto;
	}
	.figure pre, .sidefigure pre, figure pre {
		text-align: left;
		display: table;
		margin: 1em auto;
	}
	.figure table, figure table {
		margin: auto;
	}
	@media screen and (min-width: 20em) {
		.sidefigure {
			float: right;
			width: 50%;
			margin: 0 0 0.5em 0.5em
		}
	}
	.caption, figcaption, caption {
		font-style: italic;
		font-size: 90%;
	}
	.caption::before, figcaption::before, figcaption > .marker {
		font-weight: bold;
	}
	.caption, figcaption {
		counter-increment: figure;
	}

	/* DL list is indented 2em, but figure inside it is not */
	dd > .figure, dd > figure { margin-left: -2em }

/******************************************************************************/
/*                             Colored Boxes                                  */
/******************************************************************************/

	.issue, .note, .example, .assertion, .advisement, blockquote {
		padding: .5em;
		border: .5em;
		border-left-style: solid;
		page-break-inside: avoid;
	}
	span.issue, span.note {
		padding: .1em .5em .15em;
		border-right-style: solid;
	}

	.issue,
	.note,
	.example,
	.advisement,
	.assertion,
	blockquote {
		margin: 1em auto;
	}
	.note  > p:first-child,
	.issue > p:first-child,
	blockquote > :first-child {
		margin-top: 0;
	}
	blockquote > :last-child {
		margin-bottom: 0;
	}

/** Blockquotes ***************************************************************/

	blockquote {
		border-color: silver;
	}

/** Open issue ****************************************************************/

	.issue {
		border-color: #E05252;
		background: #FBE9E9;
		counter-increment: issue;
		overflow: auto;
	}
	.issue::before, .issue > .marker {
		text-transform: uppercase;
		color: #AE1E1E;
		padding-right: 1em;
		text-transform: uppercase;
	}
	/* Add .issue::before { content: "Issue " counter(issue) " "; } for autogen numbers,
	   or use class="marker" to mark up the issue number in source. */

/** Example *******************************************************************/

	.example {
		border-color: #E0CB52;
		background: #FCFAEE;
		counter-increment: example;
		overflow: auto;
		clear: both;
	}
	.example::before, .example > .marker {
		text-transform: uppercase;
		color: #827017;
		min-width: 7.5em;
		display: block;
	}
	/* Add .example::before { content: "Example " counter(example) " "; } for autogen numbers,
	   or use class="marker" to mark up the example number in source. */

/** Non-normative Note ********************************************************/

	.note {
		border-color: #52E052;
		background: #E9FBE9;
		overflow: auto;
	}

	.note::before, .note > .marker,
	details.note > summary::before,
	details.note > summary > .marker {
		text-transform: uppercase;
		display: block;
		color: hsl(120, 70%, 30%);
	}
	/* Add .note::before { content: "Note"; } for autogen label,
	   or use class="marker" to mark up the label in source. */

	details.note > summary {
		display: block;
		color: hsl(120, 70%, 30%);
	}
	details.note[open] > summary {
		border-bottom: 1px silver solid;
	}

/** Assertion Box *************************************************************/
	/*  for assertions in algorithms */

	.assertion {
		border-color: #AAA;
		background: #EEE;
	}

/** Advisement Box ************************************************************/
	/*  for attention-grabbing normative statements */

	.advisement {
		border-color: orange;
		border-style: none solid;
		background: #FFEECC;
	}
	strong.advisement {
		display: block;
		text-align: center;
	}
	.advisement > .marker {
		color: #B35F00;
	}

/** Spec Obsoletion Notice ****************************************************/
	/* obnoxious obsoletion notice for older/abandoned specs. */

	details {
		display: block;
	}
	summary {
		font-weight: bolder;
	}

	.annoying-warning:not(details),
	details.annoying-warning:not([open]) > summary,
	details.annoying-warning[open] {
		background: #fdd;
		color: red;
		font-weight: bold;
		padding: .75em 1em;
		border: thick red;
		border-style: solid;
		border-radius: 1em;
	}
	.annoying-warning :last-child {
		margin-bottom: 0;
	}

@media not print {
	details.annoying-warning[open] {
		position: fixed;
		left: 1em;
		right: 1em;
		bottom: 1em;
		z-index: 1000;
	}
}

	details.annoying-warning:not([open]) > summary {
		text-align: center;
	}

/** Entity Definition Boxes ***************************************************/

	.def {
		padding: .5em 1em;
		background: #DEF;
		margin: 1.2em 0;
		border-left: 0.5em solid #8CCBF2;
	}

/******************************************************************************/
/*                                    Tables                                  */
/******************************************************************************/

	th, td {
		text-align: left;
		text-align: start;
	}

/** Property/Descriptor Definition Tables *************************************/

	table.def {
		/* inherits .def box styling, see above */
		width: 100%;
		border-spacing: 0;
	}

	table.def td,
	table.def th {
		padding: 0.5em;
		vertical-align: baseline;
		border-bottom: 1px solid #bbd7e9;
	}

	table.def > tbody > tr:last-child th,
	table.def > tbody > tr:last-child td {
		border-bottom: 0;
	}

	table.def th {
		font-style: italic;
		font-weight: normal;
		padding-left: 1em;
		width: 3em;
	}

	/* For when values are extra-complex and need formatting for readability */
	table td.pre {
		white-space: pre-wrap;
	}

	/* A footnote at the bottom of a def table */
	table.def           td.footnote {
		padding-top: 0.6em;
	}
	table.def           td.footnote::before {
		content: " ";
		display: block;
		height: 0.6em;
		width: 4em;
		border-top: thin solid;
	}

/** Data tables (and properly marked-up index tables) *************************/
	/*
		 <table class="data"> highlights structural relationships in a table
		 when correct markup is used (e.g. thead/tbody, th vs. td, scope attribute)

		 Use class="complex data" for particularly complicated tables --
		 (This will draw more lines: busier, but clearer.)

		 Use class="long" on table cells with paragraph-like contents
		 (This will adjust text alignment accordingly.)
		 Alternately use class="longlastcol" on tables, to have the last column assume "long".
	*/

	table {
		word-wrap: normal;
		overflow-wrap: normal;
		hyphens: manual;
	}

	table.data,
	table.index {
		margin: 1em auto;
		border-collapse: collapse;
		border: hidden;
		width: 100%;
	}
	table.data caption,
	table.index caption {
		max-width: 50em;
		margin: 0 auto 1em;
	}

	table.data td,  table.data th,
	table.index td, table.index th {
		padding: 0.5em 1em;
		border-width: 1px;
		border-color: silver;
		border-top-style: solid;
	}

	table.data thead td:empty {
		padding: 0;
		border: 0;
	}

	table.data  thead,
	table.index thead,
	table.data  tbody,
	table.index tbody {
		border-bottom: 2px solid;
	}

	table.data colgroup,
	table.index colgroup {
		border-left: 2px solid;
	}

	table.data  tbody th:first-child,
	table.index tbody th:first-child  {
		border-right: 2px solid;
		border-top: 1px solid silver;
		padding-right: 1em;
	}

	table.data th[colspan],
	table.data td[colspan] {
		text-align: center;
	}

	table.complex.data th,
	table.complex.data td {
		border: 1px solid silver;
		text-align: center;
	}

	table.data.longlastcol td:last-child,
	table.data td.long {
	 vertical-align: baseline;
	 text-align: left;
	}

	table.data img {
		vertical-align: middle;
	}


/*
Alternate table alignment rules

	table.data,
	table.index {
		text-align: center;
	}

	table.data  thead th[scope="row"],
	table.index thead th[scope="row"] {
		text-align: right;
	}

	table.data  tbody th:first-child,
	table.index tbody th:first-child  {
		text-align: right;
	}

Possible extra rowspan handling

	table.data  tbody th[rowspan]:not([rowspan='1']),
	table.index tbody th[rowspan]:not([rowspan='1']),
	table.data  tbody td[rowspan]:not([rowspan='1']),
	table.index tbody td[rowspan]:not([rowspan='1']) {
		border-left: 1px solid silver;
	}

	table.data  tbody th[rowspan]:first-child,
	table.index tbody th[rowspan]:first-child,
	table.data  tbody td[rowspan]:first-child,
	table.index tbody td[rowspan]:first-child{
		border-left: 0;
		border-right: 1px solid silver;
	}
*/

/******************************************************************************/
/*                                  Indices                                   */
/******************************************************************************/


/** Table of Contents *********************************************************/

	.toc a {
		/* More spacing; use padding to make it part of the click target. */
		padding-top: 0.1rem;
		/* Larger, more consistently-sized click target */
		display: block;
		/* Reverse color scheme */
		color: black;
		border-color: #3980B5;
		border-bottom-width: 3px !important;
		margin-bottom: 0px !important;
	}
	.toc a:visited {
		border-color: #054572;
	}
	.toc a:not(:focus):not(:hover) {
		/* Allow colors to cascade through from link styling */
		border-bottom-color: transparent;
	}

	.toc, .toc ol, .toc ul, .toc li {
		list-style: none; /* Numbers must be inlined into source */
		/* because generated content isn't search/selectable and markers can't do multilevel yet */
		margin:  0;
		padding: 0;
		line-height: 1.1rem; /* consistent spacing */
	}

	/* ToC not indented until third level, but font style & margins show hierarchy */
	.toc > li             { font-weight: bold;   }
	.toc > li li          { font-weight: normal; }
	.toc > li li li       { font-size:   95%;    }
	.toc > li li li li    { font-size:   90%;    }
	.toc > li li li li .secno { font-size: 85%; }
	.toc > li li li li li { font-size:   85%;    }
	.toc > li li li li li .secno { font-size: 100%; }

	/* @supports not (display:grid) { */
		.toc > li             { margin: 1.5rem 0;    }
		.toc > li li          { margin: 0.3rem 0;    }
		.toc > li li li       { margin-left: 2rem;   }

		/* Section numbers in a column of their own */
		.toc .secno {
			float: left;
			width: 4rem;
			white-space: nowrap;
		}

		.toc li {
			clear: both;
		}

		:not(li) > .toc              { margin-left:  5rem; }
		.toc .secno                  { margin-left: -5rem; }
		.toc > li li li .secno       { margin-left: -7rem; }
		.toc > li li li li .secno    { margin-left: -9rem; }
		.toc > li li li li li .secno { margin-left: -11rem; }

		/* Tighten up indentation in narrow ToCs */
		@media (max-width: 30em) {
			:not(li) > .toc              { margin-left:  4rem; }
			.toc .secno                  { margin-left: -4rem; }
			.toc > li li li              { margin-left:  1rem; }
			.toc > li li li .secno       { margin-left: -5rem; }
			.toc > li li li li .secno    { margin-left: -6rem; }
			.toc > li li li li li .secno { margin-left: -7rem; }
		}
	/* } */

	@supports (display:grid) {
		/* Use #toc over .toc to override non-@supports rules. */
		#toc {
			display: grid;
			align-content: start;
			grid-template-columns: auto 1fr;
			grid-column-gap: 1rem;
			column-gap: 1rem;
			grid-row-gap: .6rem;
			row-gap: .6rem;
		}
		#toc h2 {
			grid-column: 1 / -1;
			margin-bottom: 0;
		}
		#toc ol,
		#toc li,
		#toc a {
			display: contents;
			/* Switch <a> to subgrid when supported */
		}
		#toc span {
			margin: 0;
		}
		#toc > .toc > li > a > span {
			/* The spans of the top-level list,
			   comprising the first items of each top-level section. */
			margin-top: 1.1rem;
		}
		#toc#toc .secno { /* Ugh, need more specificity to override base.css */
			grid-column: 1;
			width: auto;
			margin-left: 0;
		}
		#toc .content {
			grid-column: 2;
			width: auto;
			margin-right: 1rem;
		}
		#toc .content:hover {
			background: rgba(75%, 75%, 75%, .25);
			border-bottom: 3px solid #054572;
			margin-bottom: -3px;
		}
		#toc li li li .content {
			margin-left: 1rem;
		}
		#toc li li li li .content {
			margin-left: 2rem;
		}
	}


/** Index *********************************************************************/

	/* Index Lists: Layout */
	ul.index       { margin-left: 0; columns: 15em; text-indent: 1em hanging; }
	ul.index li    { margin-left: 0; list-style: none; break-inside: avoid; }
	ul.index li li { margin-left: 1em }
	ul.index dl    { margin-top: 0; }
	ul.index dt    { margin: .2em 0 .2em 20px;}
	ul.index dd    { margin: .2em 0 .2em 40px;}
	/* Index Lists: Typography */
	ul.index ul,
	ul.index dl { font-size: smaller; }
	@media not print {
		ul.index li span {
			white-space: nowrap;
			color: transparent; }
		ul.index li a:hover + span,
		ul.index li a:focus + span {
			color: #707070;
		}
	}

/** Index Tables *****************************************************/
	/* See also the data table styling section, which this effectively subclasses */

	table.index {
		font-size: small;
		border-collapse: collapse;
		border-spacing: 0;
		text-align: left;
		margin: 1em 0;
	}

	table.index td,
	table.index th {
		padding: 0.4em;
	}

	table.index tr:hover td:not([rowspan]),
	table.index tr:hover th:not([rowspan]) {
		background: #f7f8f9;
	}

	/* The link in the first column in the property table (formerly a TD) */
	table.index th:first-child a {
		font-weight: bold;
	}

/******************************************************************************/
/*                                    Print                                   */
/******************************************************************************/

	@media print {
		/* Pages have their own margins. */
		html {
			margin: 0;
		}
		/* Serif for print. */
		body {
			font-family: serif;
		}
	}
	@page {
		margin: 1.5cm 1.1cm;
	}

/******************************************************************************/
/*                                    Legacy                                  */
/******************************************************************************/

	/* This rule is inherited from past style sheets. No idea what it's for. */
	.hide { display: none }



/******************************************************************************/
/*                             Overflow Control                               */
/******************************************************************************/

	.figure .caption, .sidefigure .caption, figcaption {
		/* in case figure is overlarge, limit caption to 50em */
		max-width: 50rem;
		margin-left: auto;
		margin-right: auto;
	}
	.overlarge > table {
		/* limit preferred width of table */
		max-width: 50em;
		margin-left: auto;
		margin-right: auto;
	}

	@media (min-width: 55em) {
		.overlarge {
			margin-left: calc(13px + 26.5rem - 50vw);
			margin-right: calc(13px + 26.5rem - 50vw);
			max-width: none;
		}
	}
	@media screen and (min-width: 78em) {
		body:not(.toc-inline) .overlarge {
			/* 30.5em body padding 50em content area */
			margin-left: calc(40em - 50vw) !important;
			margin-right: calc(40em - 50vw) !important;
		}
	}
	@media screen and (min-width: 90em) {
		body:not(.toc-inline) .overlarge {
			/* 4em html margin 30.5em body padding 50em content area */
			margin-left: 0 !important;
			margin-right: calc(84.5em - 100vw) !important;
		}
	}

	@media not print {
		.overlarge {
			overflow-x: auto;
			/* See Lea Verou's explanation background-attachment:
			 * http://lea.verou.me/2012/04/background-attachment-local/
			 *
			background: top left  / 4em 100% linear-gradient(to right,  #ffffff, rgba(255, 255, 255, 0)) local,
			            top right / 4em 100% linear-gradient(to left, #ffffff, rgba(255, 255, 255, 0)) local,
			            top left  / 1em 100% linear-gradient(to right,  #c3c3c5, rgba(195, 195, 197, 0)) scroll,
			            top right / 1em 100% linear-gradient(to left, #c3c3c5, rgba(195, 195, 197, 0)) scroll,
			            white;
			background-repeat: no-repeat;
			*/
		}
	}
</style>
<style type="text/css">
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
      vertical-align: top;
    }
    th, td {
      border-left: none;
      border-right: none;
      padding: 0px 10px;
    }
    th {
      text-align: center;
    }
  </style>
  <meta content="Bikeshed version f168e9e768df676e3c9c49525fc1d754533d7501" name="generator">
  <link href="https://isocpp.org/favicon.ico" rel="icon">
<style>
ins  {background-color: #CCFFCC; text-decoration: underline;}
del  {background-color: #FFCACA; text-decoration: line-through;}
</style>
<style>/* style-md-lists */

/* This is a weird hack for me not yet following the commonmark spec
   regarding paragraph and lists. */
[data-md] > :first-child {
    margin-top: 0;
}
[data-md] > :last-child {
    margin-bottom: 0;
}</style>
<style>/* style-selflinks */

.heading, .issue, .note, .example, li, dt {
    position: relative;
}
a.self-link {
    position: absolute;
    top: 0;
    left: calc(-1 * (3.5rem - 26px));
    width: calc(3.5rem - 26px);
    height: 2em;
    text-align: center;
    border: none;
    transition: opacity .2s;
    opacity: .5;
}
a.self-link:hover {
    opacity: 1;
}
.heading > a.self-link {
    font-size: 83%;
}
li > a.self-link {
    left: calc(-1 * (3.5rem - 26px) - 2em);
}
dfn > a.self-link {
    top: auto;
    left: auto;
    opacity: 0;
    width: 1.5em;
    height: 1.5em;
    background: gray;
    color: white;
    font-style: normal;
    transition: opacity .2s, background-color .2s, color .2s;
}
dfn:hover > a.self-link {
    opacity: 1;
}
dfn > a.self-link:hover {
    color: black;
}

a.self-link::before            { content: "¶"; }
.heading > a.self-link::before { content: "§"; }
dfn > a.self-link::before      { content: "#"; }</style>
<style>/* style-counters */

body {
    counter-reset: example figure issue;
}
.issue {
    counter-increment: issue;
}
.issue:not(.no-marker)::before {
    content: "Issue " counter(issue);
}

.example {
    counter-increment: example;
}
.example:not(.no-marker)::before {
    content: "Example " counter(example);
}
.invalid.example:not(.no-marker)::before,
.illegal.example:not(.no-marker)::before {
    content: "Invalid Example" counter(example);
}

figcaption {
    counter-increment: figure;
}
figcaption:not(.no-marker)::before {
    content: "Figure " counter(figure) " ";
}</style>
<style>/* style-autolinks */

.css.css, .property.property, .descriptor.descriptor {
    color: #005a9c;
    font-size: inherit;
    font-family: inherit;
}
.css::before, .property::before, .descriptor::before {
    content: "‘";
}
.css::after, .property::after, .descriptor::after {
    content: "’";
}
.property, .descriptor {
    /* Don't wrap property and descriptor names */
    white-space: nowrap;
}
.type { /* CSS value <type> */
    font-style: italic;
}
pre .property::before, pre .property::after {
    content: "";
}
[data-link-type="property"]::before,
[data-link-type="propdesc"]::before,
[data-link-type="descriptor"]::before,
[data-link-type="value"]::before,
[data-link-type="function"]::before,
[data-link-type="at-rule"]::before,
[data-link-type="selector"]::before,
[data-link-type="maybe"]::before {
    content: "‘";
}
[data-link-type="property"]::after,
[data-link-type="propdesc"]::after,
[data-link-type="descriptor"]::after,
[data-link-type="value"]::after,
[data-link-type="function"]::after,
[data-link-type="at-rule"]::after,
[data-link-type="selector"]::after,
[data-link-type="maybe"]::after {
    content: "’";
}

[data-link-type].production::before,
[data-link-type].production::after,
.prod [data-link-type]::before,
.prod [data-link-type]::after {
    content: "";
}

[data-link-type=element],
[data-link-type=element-attr] {
    font-family: Menlo, Consolas, "DejaVu Sans Mono", monospace;
    font-size: .9em;
}
[data-link-type=element]::before { content: "<" }
[data-link-type=element]::after  { content: ">" }

[data-link-type=biblio] {
    white-space: pre;
}</style>
<style>/* style-dfn-panel */

.dfn-panel {
    position: absolute;
    z-index: 35;
    height: auto;
    width: -webkit-fit-content;
    width: fit-content;
    max-width: 300px;
    max-height: 500px;
    overflow: auto;
    padding: 0.5em 0.75em;
    font: small Helvetica Neue, sans-serif, Droid Sans Fallback;
    background: #DDDDDD;
    color: black;
    border: outset 0.2em;
}
.dfn-panel:not(.on) { display: none; }
.dfn-panel * { margin: 0; padding: 0; text-indent: 0; }
.dfn-panel > b { display: block; }
.dfn-panel a { color: black; }
.dfn-panel a:not(:hover) { text-decoration: none !important; border-bottom: none !important; }
.dfn-panel > b + b { margin-top: 0.25em; }
.dfn-panel ul { padding: 0; }
.dfn-panel li { list-style: inside; }
.dfn-panel.activated {
    display: inline-block;
    position: fixed;
    left: .5em;
    bottom: 2em;
    margin: 0 auto;
    max-width: calc(100vw - 1.5em - .4em - .5em);
    max-height: 30vh;
}

.dfn-paneled { cursor: pointer; }
</style>
<style>/* style-syntax-highlighting */

.highlight:not(.idl) { background: hsl(24, 20%, 95%); }
code.highlight { padding: .1em; border-radius: .3em; }
pre.highlight, pre > code.highlight { display: block; padding: 1em; margin: .5em 0; overflow: auto; border-radius: 0; }
.highlight .c { color: #708090 } /* Comment */
.highlight .k { color: #990055 } /* Keyword */
.highlight .l { color: #000000 } /* Literal */
.highlight .n { color: #0077aa } /* Name */
.highlight .o { color: #999999 } /* Operator */
.highlight .p { color: #999999 } /* Punctuation */
.highlight .cm { color: #708090 } /* Comment.Multiline */
.highlight .cp { color: #708090 } /* Comment.Preproc */
.highlight .c1 { color: #708090 } /* Comment.Single */
.highlight .cs { color: #708090 } /* Comment.Special */
.highlight .kc { color: #990055 } /* Keyword.Constant */
.highlight .kd { color: #990055 } /* Keyword.Declaration */
.highlight .kn { color: #990055 } /* Keyword.Namespace */
.highlight .kp { color: #990055 } /* Keyword.Pseudo */
.highlight .kr { color: #990055 } /* Keyword.Reserved */
.highlight .kt { color: #990055 } /* Keyword.Type */
.highlight .ld { color: #000000 } /* Literal.Date */
.highlight .m { color: #000000 } /* Literal.Number */
.highlight .s { color: #a67f59 } /* Literal.String */
.highlight .na { color: #0077aa } /* Name.Attribute */
.highlight .nc { color: #0077aa } /* Name.Class */
.highlight .no { color: #0077aa } /* Name.Constant */
.highlight .nd { color: #0077aa } /* Name.Decorator */
.highlight .ni { color: #0077aa } /* Name.Entity */
.highlight .ne { color: #0077aa } /* Name.Exception */
.highlight .nf { color: #0077aa } /* Name.Function */
.highlight .nl { color: #0077aa } /* Name.Label */
.highlight .nn { color: #0077aa } /* Name.Namespace */
.highlight .py { color: #0077aa } /* Name.Property */
.highlight .nt { color: #669900 } /* Name.Tag */
.highlight .nv { color: #222222 } /* Name.Variable */
.highlight .ow { color: #999999 } /* Operator.Word */
.highlight .mb { color: #000000 } /* Literal.Number.Bin */
.highlight .mf { color: #000000 } /* Literal.Number.Float */
.highlight .mh { color: #000000 } /* Literal.Number.Hex */
.highlight .mi { color: #000000 } /* Literal.Number.Integer */
.highlight .mo { color: #000000 } /* Literal.Number.Oct */
.highlight .sb { color: #a67f59 } /* Literal.String.Backtick */
.highlight .sc { color: #a67f59 } /* Literal.String.Char */
.highlight .sd { color: #a67f59 } /* Literal.String.Doc */
.highlight .s2 { color: #a67f59 } /* Literal.String.Double */
.highlight .se { color: #a67f59 } /* Literal.String.Escape */
.highlight .sh { color: #a67f59 } /* Literal.String.Heredoc */
.highlight .si { color: #a67f59 } /* Literal.String.Interpol */
.highlight .sx { color: #a67f59 } /* Literal.String.Other */
.highlight .sr { color: #a67f59 } /* Literal.String.Regex */
.highlight .s1 { color: #a67f59 } /* Literal.String.Single */
.highlight .ss { color: #a67f59 } /* Literal.String.Symbol */
.highlight .vc { color: #0077aa } /* Name.Variable.Class */
.highlight .vg { color: #0077aa } /* Name.Variable.Global */
.highlight .vi { color: #0077aa } /* Name.Variable.Instance */
.highlight .il { color: #000000 } /* Literal.Number.Integer.Long */
</style>
 <body class="h-entry">
  <div class="head">
   <p data-fill-with="logo"></p>
   <h1 class="p-name no-ref" id="title">D1144R0<br>Object relocation in terms of move plus destroy</h1>
   <h2 class="no-num no-toc no-ref heading settled" id="subtitle"><span class="content">Draft Proposal, <time class="dt-updated" datetime="2018-07-06">2018-07-06</time></span></h2>
   <div data-fill-with="spec-metadata">
    <dl>
     <dt>Issue Tracking:
     <dd><a href="#issues-index">Inline In Spec</a>
     <dt>Authors:
     <dd>
      <dd class="editor p-author h-card vcard"><a class="p-name fn u-email email" href="mailto:arthur.j.odwyer@gmail.com">Arthur O'Dwyer</a>
     <dd>
      <dd class="editor p-author h-card vcard"><a class="p-name fn u-email email" href="mailto:wmx16835vv@163.com">Mingxin Wang</a>
     <dt>Audience:
     <dd>LEWG, EWG
     <dt>Project:
     <dd>ISO/IEC JTC1/SC22/WG21 14882: Programming Language — C++
     <dt>Draft Revision:
     <dd>7
     <dt>Current Source:
     <dd><a href="https://github.com/Quuxplusone/draft/blob/gh-pages/d1144.bs">github.com/Quuxplusone/draft/blob/gh-pages/d1144.bs</a>
     <dt>Current:
     <dd><a href="https://rawgit.com/Quuxplusone/draft/gh-pages/d1144.html">rawgit.com/Quuxplusone/draft/gh-pages/d1144.html</a>
    </dl>
   </div>
   <div data-fill-with="warning"></div>
   <hr title="Separator for header">
  </div>
  <div class="p-summary" data-fill-with="abstract">
   <h2 class="no-num no-toc no-ref heading settled" id="abstract"><span class="content">Abstract</span></h2>
   <p>We define a new algorithm "relocate" which is tantamount to a move and a destroy,

analogous to the existing algorithm "swap" which is tantamount to a move, two move-assignments, and a destroy.
For most (but not all) C++ types, the "relocate" operation is equivalent to a single <code class="highlight"><span class="n">memcpy</span></code>.
For the benefit of library writers, we provide a standard type trait to detect types whose "relocate" is known to be equivalent to <code class="highlight"><span class="n">memcpy</span></code>.
Finally, we provide a portable way for any user-defined type (such as <code class="highlight"><span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span></code>) to warrant to the implementation that its "relocate" is equivalent to <code class="highlight"><span class="n">memcpy</span></code>, thus gaining the same performance benefits as the standard library types.</p>
  </div>
  <nav data-fill-with="table-of-contents" id="toc">
   <h2 class="no-num no-toc no-ref" id="contents">Table of Contents</h2>
   <ol class="toc" role="directory">
    <li><a href="#intro"><span class="secno">1</span> <span class="content">Introduction and motivation</span></a>
    <li>
     <a href="#design-goals"><span class="secno">2</span> <span class="content">Design goals</span></a>
     <ol class="toc">
      <li><a href="#use1"><span class="secno">2.1</span> <span class="content">Standard library types such as <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">string</span></code></span></a>
      <li><a href="#use2"><span class="secno">2.2</span> <span class="content">Program-defined types that follow the Rule of Zero</span></a>
      <li><a href="#use3"><span class="secno">2.3</span> <span class="content">Program-defined types with non-defaulted special members</span></a>
     </ol>
    <li><a href="#proposal"><span class="secno">3</span> <span class="content">Proposed language and library features</span></a>
    <li>
     <a href="#wording"><span class="secno">4</span> <span class="content">Proposed wording for C++20</span></a>
     <ol class="toc">
      <li><a href="#wording-operation"><span class="secno">4.1</span> <span class="content">Relocation operation</span></a>
      <li><a href="#wording-uninit-relocate"><span class="secno">4.2</span> <span class="content">Algorithm <code class="highlight"><span class="n">uninitialized_relocate</span></code></span></a>
      <li><a href="#wording-uninit-relocate-n"><span class="secno">4.3</span> <span class="content">Algorithm <code class="highlight"><span class="n">uninitialized_relocate_n</span></code></span></a>
      <li><a href="#wording-inheritance"><span class="secno">4.4</span> <span class="content">Trivially relocatable type</span></a>
      <li><a href="#wording-attribute"><span class="secno">4.5</span> <span class="content"><code class="highlight"><span class="p">[[</span><span class="n">trivially_relocatable</span><span class="p">]]</span></code> attribute</span></a>
      <li><a href="#wording-traits"><span class="secno">4.6</span> <span class="content">Type traits <code class="highlight"><span class="n">is_relocatable</span></code> etc.</span></a>
      <li><a href="#wording-concept"><span class="secno">4.7</span> <span class="content"><code class="highlight"><span class="n">Relocatable</span></code> concept</span></a>
     </ol>
    <li>
     <a href="#further"><span class="secno">5</span> <span class="content">Further considerations and directions</span></a>
     <ol class="toc">
      <li><a href="#trivially-swappable"><span class="secno">5.1</span> <span class="content">Trivially swappable types</span></a>
      <li><a href="#hetero"><span class="secno">5.2</span> <span class="content">Heterogeneous relocation</span></a>
     </ol>
    <li><a href="#acknowledgements"><span class="secno">6</span> <span class="content">Acknowledgements</span></a>
    <li>
     <a href="#polls"><span class="secno"></span> <span class="content">Appendix A: Straw polls requested</span></a>
     <ol class="toc">
      <li><a href="#lewg-polls"><span class="secno"></span> <span class="content">Polls for LEWG</span></a>
      <li><a href="#ewg-polls"><span class="secno"></span> <span class="content">Polls for EWG</span></a>
     </ol>
    <li>
     <a href="#samples"><span class="secno"></span> <span class="content">Appendix B: Sample code</span></a>
     <ol class="toc">
      <li><a href="#sample-deducing"><span class="secno"></span> <span class="content">Defining a trivially relocatable function object</span></a>
      <li><a href="#sample-opting-in"><span class="secno"></span> <span class="content">Warranting that a user-defined relocation operation is equivalent to <code class="highlight"><span class="n">memcpy</span></code></span></a>
      <li><a href="#sample-uninit-relocate"><span class="secno"></span> <span class="content">Reference implementation of <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">uninitialized_relocate</span></code></span></a>
      <li><a href="#sample-conditional"><span class="secno"></span> <span class="content">Conditionally trivial relocation</span></a>
     </ol>
    <li>
     <a href="#non-trivial-samples"><span class="secno"></span> <span class="content">Appendix C: Examples of non-trivially relocatable class types</span></a>
     <ol class="toc">
      <li><a href="#non-trivial-sample-string"><span class="secno"></span> <span class="content">Class contains pointer to self</span></a>
      <li><a href="#non-trivial-sample-offset-ptr"><span class="secno"></span> <span class="content">Class invariant depends on <code class="highlight"><span class="k">this</span></code></span></a>
      <li><a href="#non-trivial-sample-registry"><span class="secno"></span> <span class="content">Program invariant depends on <code class="highlight"><span class="k">this</span></code></span></a>
     </ol>
    <li><a href="#implementation"><span class="secno"></span> <span class="content">Appendix D: Implementation and benchmarks</span></a>
    <li>
     <a href="#index"><span class="secno"></span> <span class="content">Index</span></a>
     <ol class="toc">
      <li><a href="#index-defined-here"><span class="secno"></span> <span class="content">Terms defined by this specification</span></a>
     </ol>
    <li>
     <a href="#references"><span class="secno"></span> <span class="content">References</span></a>
     <ol class="toc">
      <li><a href="#normative"><span class="secno"></span> <span class="content">Normative References</span></a>
      <li><a href="#informative"><span class="secno"></span> <span class="content">Informative References</span></a>
     </ol>
    <li><a href="#issues-index"><span class="secno"></span> <span class="content">Issues Index</span></a>
   </ol>
  </nav>
  <main>
   <h2 class="heading settled" data-level="1" id="intro"><span class="secno">1. </span><span class="content">Introduction and motivation</span><a class="self-link" href="#intro"></a></h2>
   <p>If you are reading this paper, and you have not yet watched Arthur’s session from C++Now 2018
on <a data-link-type="biblio" href="#biblio-best">"The Best Type Traits C++ Doesn’t Have,"</a> it will help if you immediately stop reading and <a href="https://www.youtube.com/watch?v=MWBfmmg8-Yo">go watch</a> the first 30 minutes of that video at 2x speed with the captions turned on.
It’s going to be worth your 15 minutes. I’ll wait.</p>
   <p>In the video, besides showing implementation techniques and benchmark results, we defined our
terms. These terms are summarized briefly below.</p>
   <p>C++17 knows the verbs "move," "copy," "destroy," and "swap," where "swap" is a higher-level operation
composed of several lower-level operations. To this list we propose to add the verb "relocate,"
which is a higher-level operation composed of exactly two lower-level operations.
Given an object type <code class="highlight"><span class="n">T</span></code> and memory addresses <code class="highlight"><span class="n">src</span></code> and <code class="highlight"><span class="n">dst</span></code>,
the phrase "<b><i>relocate</i></b> a <code class="highlight"><span class="n">T</span></code> from <code class="highlight"><span class="n">src</span></code> to <code class="highlight"><span class="n">dst</span></code>" means no more and no
less than "<em>move-construct</em> <code class="highlight"><span class="n">dst</span></code> from <code class="highlight"><span class="n">src</span></code>, and then immediately <em>destroy</em> the object at <code class="highlight"><span class="n">src</span></code>."</p>
   <p>Just as the verb "swap" produces the adjective "swappable," the verb "relocate" produces the adjective
"relocatable." Any type which is both move-constructible and
destructible is <b><i>relocatable</i></b>. The notion can be modified by adverbs: we say that a type
is <b><i>nothrow relocatable</i></b> if its relocation operation is noexcept, and we say that a type
is <b><i><a data-link-type="abstract-op" href="#abstract-opdef-trivially-relocatable" id="ref-for-abstract-opdef-trivially-relocatable">trivially relocatable</a></i></b> if its relocation operation is trivial (which, just like trivial move-construction
and trivial copy-construction, means "the operation is tantamount to a <code class="highlight"><span class="n">memcpy</span></code>").</p>
   <p>Almost all relocatable types are trivially relocatable: <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">></span></code>, <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">></span></code>, <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">string</span></code>, <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">any</span></code>. Non-trivially relocatable
types exist but are rare: <code class="highlight"><span class="n">boost</span><span class="o">::</span><span class="n">interprocess</span><span class="o">::</span><span class="n">offset_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">></span></code>, for example.
See <a href="#non-trivial-samples">Appendix C: Examples of non-trivially relocatable class types</a>.</p>
   <p>Arthur has established (see <a data-link-type="biblio" href="#biblio-bench">[Bench]</a>)
that if standard library code had a reliable way of detecting "trivial relocatability," we could optimize
that case and get a speed boost of up to 3x on routines that perform reallocation, such as</p>
<pre class="highlight">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">R</span><span class="o">>::</span><span class="n">resize</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">R</span><span class="o">>::</span><span class="n">reserve</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">R</span><span class="o">>::</span><span class="n">emplace_back</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">R</span><span class="o">>::</span><span class="n">push_back</span>
</pre>
   <p>Furthermore, Mingxin Wang points out that we can use the same "trivial relocatability" property to shrink the code
generated by small-buffer-optimized (SBO) type-erasing wrappers such as <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">function</span></code> and <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">any</span></code>.
For these types, a <em>move</em> of the wrapper object is implemented in terms of a <em>relocation</em> of the contained object. (See for example <a data-link-type="biblio" href="#biblio-libcxxany">libc++'s std::any</a>,
where the function that performs the relocation operation is confusingly named <code class="highlight"><span class="n">__move</span></code>.)
In general, the <em>relocate</em> operation for a contained type <code class="highlight"><span class="n">C</span></code> involves calls to <code class="highlight"><span class="n">C</span></code>'s
move constructor and destructor, which must be uniquely codegenned for each different <code class="highlight"><span class="n">C</span></code>; the
number of instantiations of <em>relocate</em> scales linearly with the count of distinct types <code class="highlight"><span class="n">C</span></code> in the program.
But for any trivially relocatable <code class="highlight"><span class="n">C</span></code>, its <em>relocate</em> operation depends only on the number of
bytes being <code class="highlight"><span class="n">memcpy</span></code>ed, and so the number of instantiations of <em>relocate</em> scales linearly with the count
of distinct <em>sizes</em> of <code class="highlight"><span class="n">C</span></code> being used in the program; or indeed, linearly with the count
of distinct <em>sizes of SBO buffer</em> being used in the program.</p>
   <p>A smaller number of instantiations means faster compile times, a smaller text section, and perhaps
"hotter" code (because a relatively higher proportion of your code now fits in icache).</p>
   <p>In between these two scenarios, we also find the move-constructor of <code class="highlight"><span class="n">fixed_capacity_vector</span><span class="o">&lt;</span><span class="n">R</span><span class="p">,</span><span class="n">N</span><span class="o">></span></code>,
which can be implemented as an element-by-element <em>move</em> (leaving the source vector’s elements in their
moved-from state), or can be implemented more efficiently as an element-by-element <em>relocate</em> (leaving
the source vector empty).</p>
   <p class="note" role="note"><span>Note:</span> The name <code class="highlight"><span class="n">fixed_capacity_vector</span></code> is my preferred name for the type
that Boost.Container calls <code class="highlight"><span class="n">static_vector</span></code>. <code class="highlight"><span class="n">boost</span><span class="o">::</span><span class="n">container</span><span class="o">::</span><span class="n">static_vector</span><span class="o">&lt;</span><span class="n">R</span><span class="p">,</span><span class="n">N</span><span class="o">></span></code> implements the
less efficient element-by-element-move strategy. Moving-out-of a <code class="highlight"><span class="n">boost</span><span class="o">::</span><span class="n">container</span><span class="o">::</span><span class="n">static_vector</span></code> will not make the source vector <code class="highlight"><span class="n">empty</span><span class="p">()</span></code>.</p>
   <h2 class="heading settled" data-level="2" id="design-goals"><span class="secno">2. </span><span class="content">Design goals</span><a class="self-link" href="#design-goals"></a></h2>
   <p>Every C++ type already <em>is</em> or <em>is not</em> trivially relocatable. This proposal is not about
"making more types trivially relocatable."</p>
   <p>The optimizations discussed above are purely in the domain of library vendors. If you’re writing
a vector, and you detect that your element type <code class="highlight"><span class="n">T</span></code> is trivially relocatable, then
whether you do any special optimization in that case is merely a Quality of Implementation (QoI) issue.
This proposal is not about "standardizing certain library optimizations."</p>
   <p>What C++ lacks is a standard way for library vendors to <em>detect</em> the (existing) trivial relocatability
of a type <code class="highlight"><span class="n">T</span></code>, so that they can reliably apply their (existing) optimizations.
All we really need is to add <em>detection</em>, and then all the optimizations described above will naturally
emerge without any further special effort by WG21.</p>
   <p>Library vendors today often (correctly) infer that any <em>trivially copyable</em> type is trivially relocatable.
However, we would like to do even better. The following three use-cases are important for improving the
performance of real programs:</p>
   <h3 class="heading settled" data-level="2.1" id="use1"><span class="secno">2.1. </span><span class="content">Standard library types such as <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">string</span></code></span><a class="self-link" href="#use1"></a></h3>
   <p>In order to optimize <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">>::</span><span class="n">resize</span></code>, we must come up with a way to achieve</p>
<pre class="language-c++ highlight">    <span class="cp">#include</span> &lt;string><span class="cp"></span>
<span class="cp"></span>    <span class="n">static_assert</span><span class="p">(</span><span class="n">is_trivially_relocatable</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">>::</span><span class="n">value</span><span class="p">);</span>
</pre>
   This could be done unilaterally by the library vendor, via a non-standard attribute
(<code class="highlight"><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">trivially_relocatable</span><span class="p">]]</span></code>), or a member typedef with a reserved name
(<code class="highlight"><span class="k">using</span> <span class="n">__is_triv_relocatable</span> <span class="o">=</span> <span class="kt">void</span></code>), or simply a vendor-provided specialization
of <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">is_trivially_relocatable</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">></span></code>. 
   <p>That is, we can in principle solve §2.1 while confining our "magic" to the headers
of the implementation itself. The programmer doesn’t have to learn anything new, so far.</p>
   <h3 class="heading settled" data-level="2.2" id="use2"><span class="secno">2.2. </span><span class="content">Program-defined types that follow the Rule of Zero</span><a class="self-link" href="#use2"></a></h3>
   <p class="note" role="note"><span>Note:</span> The term "program-defined types" is defined in <a data-link-type="biblio" href="#biblio-lwg2139">[LWG2139]</a> and <a data-link-type="biblio" href="#biblio-lwg3119">[LWG3119]</a>.</p>
   <p>In order to optimize the SBO <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">function</span></code> in any meaningful sense,
we must come up with a way to achieve</p>
<pre class="language-c++ highlight">    <span class="cp">#include</span> &lt;string><span class="cp"></span>
<span class="cp"></span>    <span class="k">auto</span> <span class="n">lam2</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"hello"</span><span class="p">)]{};</span>
    <span class="n">static_assert</span><span class="p">(</span><span class="n">is_trivially_relocatable</span><span class="o">&lt;</span> <span class="n">decltype</span><span class="p">(</span><span class="n">lam2</span><span class="p">)</span> <span class="o">>::</span><span class="n">value</span><span class="p">);</span>
</pre>
   Lambdas are not a special case in C++; they are simply class types with all their special members defaulted.
Therefore, presumably we should be able to use the same solution for lambdas as for 
<pre class="language-c++ highlight">    <span class="cp">#include</span> &lt;string><span class="cp"></span>
<span class="cp"></span>    <span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="n">static_assert</span><span class="p">(</span><span class="n">is_trivially_relocatable</span><span class="o">&lt;</span> <span class="n">A</span> <span class="o">>::</span><span class="n">value</span><span class="p">);</span>
</pre>
   Here <code class="highlight"><span class="k">struct</span> <span class="n">A</span></code> follows the Rule of Zero: its move-constructor and destructor are both defaulted.
If they were also <em>trivial</em>, then we’d be done. In fact they are non-trivial; and yet, because the type’s
bases and members are all of trivially relocatable types, the type as a whole <em>is</em> trivially relocatable. 
   <p>§2.2 asks specifically that we make the <code class="highlight"><span class="k">static_assert</span></code> succeed without breaking the "Rule of Zero."
We do not want to require the programmer to annotate <code class="highlight"><span class="k">struct</span> <span class="n">A</span></code> with a special attribute, or
a special member typedef, or anything like that. We want it to Just Work. Even for lambda types.
This is a much harder problem than §2.1; it requires standard support in the core language.
But it still does not require any new <em>syntax</em>.</p>
   <h3 class="heading settled" data-level="2.3" id="use3"><span class="secno">2.3. </span><span class="content">Program-defined types with non-defaulted special members</span><a class="self-link" href="#use3"></a></h3>
   <p>In order to optimize <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">>>::</span><span class="n">resize</span></code>,
we must come up with a way to achieve</p>
<pre class="language-c++ highlight">    <span class="k">struct</span> <span class="n">B</span> <span class="p">{</span>
        <span class="n">B</span><span class="p">(</span><span class="n">B</span><span class="o">&amp;&amp;</span><span class="p">);</span>  <span class="c1">// non-trivial</span>
<span class="c1"></span>        <span class="o">~</span><span class="n">B</span><span class="p">();</span>  <span class="c1">// non-trivial</span>
<span class="c1"></span>    <span class="p">};</span>
    <span class="n">static_assert</span><span class="p">(</span><span class="n">is_trivially_relocatable</span><span class="o">&lt;</span> <span class="n">B</span> <span class="o">>::</span><span class="n">value</span><span class="p">);</span>
</pre>
   via some kind of programmer-provided annotation. 
   <p class="note" role="note"><span>Note:</span> We cannot possibly do it without annotation, because there exist
examples of types that look just like <code class="highlight"><span class="n">B</span></code> and <em>are</em> trivially relocatable (for example, <a data-link-type="biblio" href="#biblio-libstdcxxfunction">libstdc++'s std::function</a>) and there exist types that look just like <code class="highlight"><span class="n">B</span></code> and are <em>not</em> trivially relocatable (for example, <a data-link-type="biblio" href="#biblio-libcxxfunction">libc++'s std::function</a>).
The compiler cannot "crack open" the definitions of <code class="highlight"><span class="n">B</span><span class="p">(</span><span class="n">B</span><span class="o">&amp;&amp;</span><span class="p">)</span></code> and <code class="highlight"><span class="o">~</span><span class="n">B</span><span class="p">()</span></code> to see if
they combine to form a trivial operation. One, that’s the Halting Problem. Two,
the definitions of <code class="highlight"><span class="n">B</span><span class="p">(</span><span class="n">B</span><span class="o">&amp;&amp;</span><span class="p">)</span></code> and <code class="highlight"><span class="o">~</span><span class="n">B</span><span class="p">()</span></code> might not be available in this translation
unit. Three, the definitions might actually be
available and "crackable" in <em>this</em> translation unit, but unavailable in some other translation unit!
This would lead to ODR violations and generally really bad stuff. So we cannot achieve
our goal by avoiding annotation.</p>
   <p>This use-case is the only one that requires us to design the "opt-in" syntax.
In <a href="#use1">§2.1 Standard library types such as std::string</a>, any special syntax is hidden inside the
implementation’s own headers. In <a href="#use2">§2.2 Program-defined types that follow the Rule of Zero</a>, our design goal is to <em>avoid</em> special syntax.
In <a href="#use3">§2.3 Program-defined types with non-defaulted special members</a>, WG21 must actually design user-facing syntax.</p>
   <p>Therefore, I believe it would be acceptable to punt on §2.3 and come back to it later.
We say, "Sure, that would be nice, but there’s no syntax for it. Be glad that it works for
core-language and library types. Ask again in three years."  And as long as we leave the design
space open, I believe we wouldn’t lose anything by delaying a solution to §2.3.</p>
   <p>This paper does propose a standard syntax for §2.3 — an attribute — which in turn
provides a <em>simple and portable</em> solution to §2.1 for library vendors. However, our
attribute-based syntax is severable from the rest of this paper. With extremely minor surgery,
WG21 could reject our new attribute and still solve §2.1 and §2.2 for C++20.</p>
   <h2 class="heading settled" data-level="3" id="proposal"><span class="secno">3. </span><span class="content">Proposed language and library features</span><a class="self-link" href="#proposal"></a></h2>
   <p>This paper proposes five separate additions to the C++ Standard. These additions introduce
"relocate" as a well-supported C++ notion on par with "swap," and furthermore, successfully
communicate trivial relocatability in each of the three use-cases above.</p>
   <ul>
    <li data-md="">
     <p>A new standard algorithm, <code class="highlight"><span class="n">uninitialized_relocate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">d_first</span><span class="p">)</span></code>,
in the <code class="highlight"><span class="o">&lt;</span><span class="n">memory</span><span class="o">></span></code> header.</p>
    <li data-md="">
     <p>Additional type traits, <code class="highlight"><span class="n">is_relocatable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span></code> and <code class="highlight"><span class="n">is_nothrow_relocatable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span></code>,
in the <code class="highlight"><span class="o">&lt;</span><span class="n">type_traits</span><span class="o">></span></code> header.</p>
    <li data-md="">
     <p>A new type trait, <code class="highlight"><span class="n">is_trivially_relocatable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span></code>, in the <code class="highlight"><span class="o">&lt;</span><span class="n">type_traits</span><span class="o">></span></code> header. This is the <em>detection</em> mechanism.</p>
    <li data-md="">
     <p>A new core-language rule by which a class type’s "trivial relocatability"
is inherited according to the Rule of Zero.</p>
    <li data-md="">
     <p>A new attribute, <code class="highlight"><span class="p">[[</span><span class="n">trivially_relocatable</span><span class="p">]]</span></code>, in the core language.
This is the <em>opt-in</em> mechanism for program-defined types.</p>
   </ul>
   <p>These five bullet points are severable to a certain degree. For example, if the <code class="highlight"><span class="p">[[</span><span class="n">trivially_relocatable</span><span class="p">]]</span></code> attribute (points 4 and 5) is adopted, library vendors will certainly use it in their implementations;
but if the attribute is rejected, library vendors could still indicate the trivial relocatability
for certain standard library types by providing library specializations of <code class="highlight"><span class="n">is_trivially_relocatable</span></code> (point 3).</p>
   <p>Points 1 and 2 are completely severable from points 3, 4, and 5;
but we believe these algorithms should be provided for symmetry with the
other uninitialized-memory algorithms in the <code class="highlight"><span class="o">&lt;</span><span class="n">memory</span><span class="o">></span></code> header
(<code class="highlight"><span class="n">uninitialized_copy</span></code>, <code class="highlight"><span class="n">uninitialized_move</span></code>, and <code class="highlight"><span class="n">destroy</span></code>)
and the other trios of type-traits in the <code class="highlight"><span class="o">&lt;</span><span class="n">type_traits</span><span class="o">></span></code> header
(one such trio being <code class="highlight"><span class="n">is_destructible</span></code>, <code class="highlight"><span class="n">is_nothrow_destructible</span></code>, <code class="highlight"><span class="n">is_trivially_destructible</span></code>). I do not expect these templates to be frequently useful,
but I believe they must be provided, so as not to unpleasantly surprise the programmer
by their absence.</p>
   <p>Points 3 and 4 together motivate point 5. In order to achieve the goal of <a href="#use2">§2.2 Program-defined types that follow the Rule of Zero</a>,
we <em>must</em> define a core-language mechanism by which we can "inherit" trivial relocatability.
This is especially important for the template case.</p>
<pre class="language-c++ highlight">    <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">></span>
    <span class="k">struct</span> <span class="n">D</span> <span class="p">{</span>
        <span class="n">T</span> <span class="n">t</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="c1">// class C comes in from outside, already marked, via whatever mechanism</span>
<span class="c1"></span>    <span class="n">constexpr</span> <span class="kt">bool</span> <span class="n">c</span> <span class="o">=</span> <span class="n">is_trivially_relocatable</span><span class="o">&lt;</span> <span class="n">C</span> <span class="o">>::</span><span class="n">value</span><span class="p">;</span>
    <span class="n">constexpr</span> <span class="kt">bool</span> <span class="n">dc</span> <span class="o">=</span> <span class="n">is_trivially_relocatable</span><span class="o">&lt;</span> <span class="n">D</span><span class="o">&lt;</span><span class="n">C</span><span class="o">></span> <span class="o">>::</span><span class="n">value</span><span class="p">;</span>
    <span class="n">static_assert</span><span class="p">(</span><span class="n">dc</span> <span class="o">==</span> <span class="n">c</span><span class="p">);</span>
</pre>
   We propose that <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">is_trivially_relocatable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span></code> should be just a plain old
class template, exactly like <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">is_trivially_destructible</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span></code> and so on.
The core language *<a data-link-type="biblio" href="#biblio-contra">should not know or care</a>* that the class template <code class="highlight"><span class="n">is_trivially_relocatable</span></code> exists, any more than it knows that the class template <code class="highlight"><span class="n">is_trivially_destructible</span></code> exists. 
   <p>We expect that the library vendor will implement <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">is_trivially_relocatable</span></code>,
just like <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">is_trivially_destructible</span></code>, in terms of a non-standard compiler
builtin whose natural spelling is <code class="highlight"><span class="n">__is_trivially_relocatable</span><span class="p">(</span><span class="n">T</span><span class="p">)</span></code>. The compiler
computes the value of <code class="highlight"><span class="n">__is_trivially_relocatable</span><span class="p">(</span><span class="n">T</span><span class="p">)</span></code> by inspecting the
definition of <code class="highlight"><span class="n">T</span></code> (and the definitions of its base classes and members,
recursively, in the case that both of its special members are defaulted). This
recursive process "bottoms out" at primitive types, or at any type with a user-provided
move or destroy operation. Classes with user-provided move or destroy operations must
conservatively be assumed <em>not</em> to be trivially relocatable. To achieve the goal
of <a href="#use3">§2.3 Program-defined types with non-defaulted special members</a>, we must provide a way for such a class to "opt in" and warrant to the
implementation that it is in fact trivially relocatable (despite being non-trivially
move-constructible and/or non-trivially destructible).</p>
   <p>In point 5 we propose that the opt-in mechanism should be an attribute. The programmer
of a trivially relocatable but non-trivially destructible class <code class="highlight"><span class="n">C</span></code> will mark it for
the compiler using the attribute:</p>
<pre class="language-c++ highlight">    <span class="k">struct</span> <span class="p">[[</span><span class="n">trivially_relocatable</span><span class="p">]]</span> <span class="n">C</span> <span class="p">{</span>
        <span class="n">C</span><span class="p">(</span><span class="n">C</span><span class="o">&amp;&amp;</span><span class="p">);</span>  <span class="c1">// defined elsewhere</span>
<span class="c1"></span>        <span class="o">~</span><span class="n">C</span><span class="p">();</span> <span class="c1">// defined elsewhere</span>
<span class="c1"></span>    <span class="p">};</span>
    <span class="n">static_assert</span><span class="p">(</span><span class="n">is_trivially_relocatable</span><span class="o">&lt;</span> <span class="n">C</span> <span class="o">>::</span><span class="n">value</span><span class="p">);</span>
</pre>
   The attribute overrides the compiler’s usual computation. An example of a "conditionally"
trivially relocatable class is shown in <a href="#sample-conditional">Conditionally trivial relocation</a>. 
   <h2 class="heading settled" data-level="4" id="wording"><span class="secno">4. </span><span class="content">Proposed wording for C++20</span><a class="self-link" href="#wording"></a></h2>
   <p>The wording in this section is relative to <a data-link-type="biblio" href="#biblio-n4750">WG21 draft N4750</a>,
that is, the current draft of the C++17 standard.</p>
   <h3 class="heading settled" data-level="4.1" id="wording-operation"><span class="secno">4.1. </span><span class="content">Relocation operation</span><a class="self-link" href="#wording-operation"></a></h3>
   <p>Add a new section in <a href="http://eel.is/c++draft/definitions">[definitions]</a>:</p>
   <p class="issue" id="issue-75ffe201"><a class="self-link" href="#issue-75ffe201"></a> [definitions] is probably the wrong place for the core-language definition of "relocation operation"</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <dl><dt data-md=""><dfn class="dfn-paneled" data-dfn-type="abstract-op" data-export="" id="abstract-opdef-relocation-operation">relocation operation</dfn></dt><dd data-md=""><p>the homogeneous binary operation performed on a range by <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">uninitialized_relocate</span></code>, consisting of a move-construction immediately followed by a destruction of the source object</p> </dd></dl> </small>
   </blockquote>
   <p class="issue" id="issue-7c86f5f7"><a class="self-link" href="#issue-7c86f5f7"></a> this definition of "relocation operation" is not good</p>
   <h3 class="heading settled" data-level="4.2" id="wording-uninit-relocate"><span class="secno">4.2. </span><span class="content">Algorithm <code class="highlight"><span class="n">uninitialized_relocate</span></code></span><a class="self-link" href="#wording-uninit-relocate"></a></h3>
   <p>Add a new section after <a href="http://eel.is/c++draft/uninitialized.move">[uninitialized.move]</a>:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ForwardIterator</span><span class="o">></span>
<span class="n">ForwardIterator</span> <span class="n">uninitialized_relocate</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">,</span>
                                       <span class="n">ForwardIterator</span> <span class="n">result</span><span class="p">);</span>
</pre> <p><em>Effects:</em> Equivalent to:</p> <pre class="highlight"><span class="k">for</span> <span class="p">(;</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="o">++</span><span class="n">result</span><span class="p">,</span> <span class="o">++</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">::</span><span class="k">new</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*></span><span class="p">(</span><span class="n">addressof</span><span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="p">)))</span>
    <span class="k">typename</span> <span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">ForwardIterator</span><span class="o">>::</span><span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">));</span>
  <span class="n">destroy_at</span><span class="p">(</span><span class="n">addressof</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">));</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</pre></small>
   </blockquote>
   <h3 class="heading settled" data-level="4.3" id="wording-uninit-relocate-n"><span class="secno">4.3. </span><span class="content">Algorithm <code class="highlight"><span class="n">uninitialized_relocate_n</span></code></span><a class="self-link" href="#wording-uninit-relocate-n"></a></h3>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Size</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ForwardIterator</span><span class="o">></span>
  <span class="n">pair</span><span class="o">&lt;</span><span class="n">InputIterator</span><span class="p">,</span> <span class="n">ForwardIterator</span><span class="o">></span>
    <span class="n">uninitialized_relocate_n</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Size</span> <span class="n">n</span><span class="p">,</span> <span class="n">ForwardIterator</span> <span class="n">result</span><span class="p">);</span>
</pre> <p><em>Effects:</em> Equivalent to:</p> <pre class="highlight"><span class="k">for</span> <span class="p">(;</span> <span class="n">n</span> <span class="o">></span> <span class="mi">0</span><span class="p">;</span> <span class="o">++</span><span class="n">result</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">++</span><span class="n">first</span><span class="p">,</span> <span class="o">--</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">::</span><span class="k">new</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*></span><span class="p">(</span><span class="n">addressof</span><span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="p">)))</span>
    <span class="k">typename</span> <span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">ForwardIterator</span><span class="o">>::</span><span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">));</span>
  <span class="n">destroy_at</span><span class="p">(</span><span class="n">addressof</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">));</span>
<span class="p">}</span>
<span class="k">return</span> <span class="p">{</span><span class="n">first</span><span class="p">,</span><span class="n">result</span><span class="p">};</span>
</pre></small>
   </blockquote>
   <h3 class="heading settled" data-level="4.4" id="wording-inheritance"><span class="secno">4.4. </span><span class="content">Trivially relocatable type</span><a class="self-link" href="#wording-inheritance"></a></h3>
   <p class="issue" id="issue-ffbbd33c"><a class="self-link" href="#issue-ffbbd33c"></a> Where in the Standard should we place the definition of "trivially relocatable"?</p>
   <p>Add a new section somewhere:</p>
   <p><small></small></p>
   <blockquote><small> A move-constructible, destructible object type <code class="highlight"><span class="n">T</span></code> is a <dfn class="dfn-paneled" data-dfn-type="abstract-op" data-export="" id="abstract-opdef-trivially-relocatable">trivially relocatable</dfn> type if it is:<p></p> <ul><li data-md=""><p>a trivially copyable type, or</p> </li><li data-md=""><p>a (possibly cv-qualified) class type declared with the <code class="highlight"><span class="p">[[</span><span class="n">trivially_relocatable</span><span class="p">]]</span></code> attribute, or</p> </li><li data-md=""><p>a (possibly cv-qualified) class type which:</p> <ul><li data-md=""><p>has either a defaulted, non-deleted move constructor or no move constructor and a defaulted, non-deleted copy constructor,</p> </li><li data-md=""><p>has a defaulted, non-deleted destructor,</p> </li><li data-md=""><p>either is final, or has a final destructor, or has a non-virtual destructor,</p> </li><li data-md=""><p>has no virtual base classes,</p> </li><li data-md=""><p>has no <code class="highlight"><span class="k">mutable</span></code> members,</p> </li><li data-md=""><p>all of whose members are either of reference type or of trivially relocatable type, and</p> </li><li data-md=""><p>all of whose base classes are trivially relocatable.</p> </li></ul></li></ul> <p>[<em>Note:</em> For a trivially relocatable type, the <a data-link-type="abstract-op" href="#abstract-opdef-relocation-operation" id="ref-for-abstract-opdef-relocation-operation">relocation operation</a> (such as the relocation operations
performed by the library functions <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">swap</span></code> and <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">::</span><span class="n">resize</span></code>) is tantamount
to a simple copy of the underlying bytes. <em>—end note</em>]</p> <p>[<em>Note:</em> It is intended that most standard library types be trivially relocatable types. <em>—end note</em>]</p> </small></blockquote>
   <p class="note" role="note"><span>Note:</span> We could simplify the wording by removing the words "either is final, or has a final destructor, or".
However, this would lead to the compiler’s failing
to identify certain (unrealistic) class types as trivially relocatable, when in fact it has enough
information to infer that they <em>are</em> trivially relocatable in practice. This would leave room for a
"better" implementation beneath ours. I tentatively prefer to optimize for maximum performance over spec simplicity.</p>
   <p class="note" role="note"><span>Note:</span> There is no special treatment for <code class="highlight"><span class="k">volatile</span></code> subobjects. Using <code class="highlight"><span class="n">memmove</span></code> on <code class="highlight"><span class="k">volatile</span></code> subobjects
can cause tearing of reads and writes. Issues <a data-link-type="biblio" href="#biblio-cwg496">[CWG496]</a> and <a data-link-type="biblio" href="#biblio-cwg1746">[CWG1746]</a> aimed to evict <code class="highlight"><span class="k">volatile</span></code> objects and subobjects from the set of "trivially copyable types," but these changes were reverted
by <a data-link-type="biblio" href="#biblio-cwg2094">[CWG2094]</a> (2016). As of C++17, bytewise copying of <code class="highlight"><span class="k">volatile</span></code> subobjects is permitted
by <a data-link-type="biblio" href="#biblio-basictypes">[basic.types]</a>. Arthur has a paper coming for this.</p>
   <p class="note" role="note"><span>Note:</span> There is no special treatment for possibly overlapping subobjects. Using <code class="highlight"><span class="n">memmove</span></code> on possibly overlapping
subobjects can overwrite unrelated objects in the vicinity of the destination. This paper introduces
no <em>new</em> issues in this area. See <a data-link-type="biblio" href="#biblio-subobjects">[Subobjects]</a>.</p>
   <p class="issue" id="issue-a0d45ced"><a class="self-link" href="#issue-a0d45ced"></a> Must we also say that the relevant move constructor (resp. copy constructor) must be public and unambiguous?</p>
   <div class="issue" id="issue-97d92dd0">
    <a class="self-link" href="#issue-97d92dd0"></a> Consider the following test case—<wbr>
<pre class="highlight">    <span class="k">struct</span> <span class="n">M</span> <span class="p">{</span>
        <span class="n">M</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">M</span><span class="p">(</span><span class="n">M</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="n">puts</span><span class="p">(</span><span class="s">"evil"</span><span class="p">);</span> <span class="p">}</span>
        <span class="n">M</span><span class="p">(</span><span class="k">const</span> <span class="n">M</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">struct</span> <span class="n">T</span> <span class="p">{</span>
        <span class="k">mutable</span> <span class="n">M</span> <span class="n">m</span><span class="p">;</span>
        <span class="o">~</span><span class="n">T</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">static_assert</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">is_trivially_relocatable_v</span><span class="o">&lt;</span><span class="n">M</span><span class="o">></span> <span class="p">);</span>
    <span class="k">static_assert</span><span class="p">(</span> <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_trivially_relocatable_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span> <span class="p">);</span>
</pre>
    The declaration <code class="highlight"><span class="n">M</span> <span class="nf">m2</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m</span><span class="p">));</span></code> causes a call to the trivial, defaulted copy constructor <code class="highlight"><span class="n">M</span><span class="p">(</span><span class="k">const</span> <span class="n">M</span><span class="o">&amp;</span><span class="p">)</span></code>, and <code class="highlight"><span class="n">M</span></code> is trivially destructible as well, so we would like <code class="highlight"><span class="n">M</span></code> to be trivially relocatable. But the declaration <code class="highlight"><span class="n">T</span> <span class="nf">t2</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t</span><span class="p">));</span></code> surprisingly causes a call to the user-provided <code class="highlight"><span class="n">M</span><span class="p">(</span><span class="n">M</span><span class="o">&amp;</span><span class="p">)</span></code>, so <code class="highlight"><span class="n">T</span></code> cannot possibly be trivially
relocatable. It may be overly conservative of us to ban <code class="highlight"><span class="k">mutable</span></code> members, but at least we know it is <em>sufficiently</em> conservative. As always, the programmer may explicitly override the compiler’s judgment by declaring <code class="highlight"><span class="n">T</span></code> as <code class="highlight"><span class="p">[[</span><span class="n">trivially_relocatable</span><span class="p">]]</span></code>. 
   </div>
   <h3 class="heading settled" data-level="4.5" id="wording-attribute"><span class="secno">4.5. </span><span class="content"><code class="highlight"><span class="p">[[</span><span class="n">trivially_relocatable</span><span class="p">]]</span></code> attribute</span><a class="self-link" href="#wording-attribute"></a></h3>
   <p>Add a new section after <a href="http://eel.is/c++draft/dcl.attr.nouniqueaddr">[dcl.attr.nouniqueattr]</a>:</p>
   <p><small></small></p>
   <blockquote><small> The <em>attribute-token</em> <code class="highlight"><span class="n">trivially_relocatable</span></code> specifies that a class type’s relocation operation has no
visible side-effects other than a copy of the underlying bytes, as if by the library function <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">memcpy</span></code>.
It shall appear at most once in each <em>attribute-list</em> and no <em>attribute-argument-clause</em> shall be present.
It may be applied to the declaration of a class.
The first declaration of a type shall specify the <code class="highlight"><span class="n">trivially_relocatable</span></code> attribute if any declaration of that type
specifies the <code class="highlight"><span class="n">trivially_relocatable</span></code> attribute.
If a type is declared with the <code class="highlight"><span class="n">trivially_relocatable</span></code> attribute in one translation unit and the
same type is declared without the <code class="highlight"><span class="n">trivially_relocatable</span></code> attribute in another translation unit,
the program is ill-formed, no diagnostic required.<p></p> <p>If a type <code class="highlight"><span class="n">T</span></code> is declared with the <code class="highlight"><span class="n">trivially_relocatable</span></code> attribute, and <code class="highlight"><span class="n">T</span></code> is either not move-constructible
or not destructible, the program is ill-formed.</p> <p>If a class type is declared with the <code class="highlight"><span class="n">trivially_relocatable</span></code> attribute, the implementation may replace
relocation operations involving that type (such as those performed by the library functions <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">swap</span></code> and <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">::</span><span class="n">resize</span></code>) with simple copies of the underlying bytes.</p> <p>If a class type is declared with the <code class="highlight"><span class="n">trivially_relocatable</span></code> attribute, and the program relies on
observable side-effects of relocation other than a copy of the underlying bytes, the behavior is undefined.</p> </small></blockquote>
   <h3 class="heading settled" data-level="4.6" id="wording-traits"><span class="secno">4.6. </span><span class="content">Type traits <code class="highlight"><span class="n">is_relocatable</span></code> etc.</span><a class="self-link" href="#wording-traits"></a></h3>
   <p>Add new entries to Table 46 in <a href="http://eel.is/c++draft/meta.unary.prop">[meta.unary.prop]</a>:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <table> <tbody><tr><th>Template</th><th>Condition</th><th>Preconditions</th></tr> <tr> <td><code class="highlight"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">></span> <span class="k">struct</span> <span class="n">is_relocatable</span><span class="p">;</span></code></td> <td><code class="highlight"><span class="n">is_move_constructible_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span></code> is <code class="highlight">true</code> and <code class="highlight"><span class="n">is_destructible_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span></code> is <code class="highlight">true</code></td> <td>T shall be a complete type, <i>cv</i> <code class="highlight"><span class="kt">void</span></code>, or an array of unknown bound.</td> </tr> <tr> <td><code class="highlight"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">></span> <span class="k">struct</span> <span class="n">is_nothrow_relocatable</span><span class="p">;</span></code></td> <td><code class="highlight"><span class="n">is_relocatable_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span></code> is <code class="highlight">true</code> and both the indicated move-constructor and the destructor are known not to throw any exceptions.</td> <td>T shall be a complete type, <i>cv</i> <code class="highlight"><span class="kt">void</span></code>, or an array of unknown bound.</td> </tr> <tr> <td><code class="highlight"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">></span> <span class="k">struct</span> <span class="n">is_trivially_relocatable</span><span class="p">;</span></code></td> <td><code class="highlight"><span class="n">T</span></code> is a <a data-link-type="abstract-op" href="#abstract-opdef-trivially-relocatable" id="ref-for-abstract-opdef-trivially-relocatable①">trivially relocatable</a> type.</td> <td>T shall be a complete type, <i>cv</i> <code class="highlight"><span class="kt">void</span></code>, or an array of unknown bound.</td> </tr> </tbody></table> </small>
   </blockquote>
   <h3 class="heading settled" data-level="4.7" id="wording-concept"><span class="secno">4.7. </span><span class="content"><code class="highlight"><span class="n">Relocatable</span></code> concept</span><a class="self-link" href="#wording-concept"></a></h3>
   <p>Add a new section after <a href="http://eel.is/c++draft/concept.moveconstructible">[concept.moveconstructible]</a>:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">></span>
  <span class="n">concept</span> <span class="n">Relocatable</span> <span class="o">=</span> <span class="n">MoveConstructible</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span> <span class="o">&amp;&amp;</span> <span class="n">Destructible</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span><span class="p">;</span>
</pre> <p><em>Note:</em> This concept is exactly equivalent to <code class="highlight"><span class="n">MoveConstructible</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span></code>.</p> </small>
   </blockquote>
   <h2 class="heading settled" data-level="5" id="further"><span class="secno">5. </span><span class="content">Further considerations and directions</span><a class="self-link" href="#further"></a></h2>
   <h3 class="heading settled" data-level="5.1" id="trivially-swappable"><span class="secno">5.1. </span><span class="content">Trivially swappable types</span><a class="self-link" href="#trivially-swappable"></a></h3>
   <p><a data-link-type="biblio" href="#biblio-wang">Mingxin Wang has proposed</a> that "swap"
could be expressed in terms of "relocate". <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">swap</span></code> today is
typically implemented in terms of one move-construction, two move-assignments,
and one destruction; but there is nothing in the Standard that prevents a library
vendor from implementing it as three relocations, which in the trivially-relocatable
case (the usual case for most types) could be optimized into three calls to <code class="highlight"><span class="n">memcpy</span></code>.</p>
   <p>For reasons <a data-link-type="biblio" href="#biblio-sane">described elsewhere</a>, it seems reasonable
to claim that move-assignment must always "do the sane thing," and therefore we
might propose to define <small></small></p>
   <small> <pre class="language-c++ highlight"><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">></span>
<span class="k">struct</span> <span class="nl">is_trivially_swappable</span> <span class="p">:</span> <span class="n">bool_constant</span><span class="o">&lt;</span>
    <span class="n">is_trivially_relocatable_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span> <span class="o">&amp;&amp;</span>
    <span class="n">is_move_assignable_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span>
<span class="o">></span> <span class="p">{};</span>
</pre></small> thus completing the currently-incomplete trio with <code class="highlight"><span class="n">is_swappable</span></code> and <code class="highlight"><span class="n">is_nothrow_swappable</span></code>. 
   <p>However, we do not propose "trivially swappable" at the present time.
It can easily be added in a later paper.</p>
   <h3 class="heading settled" data-level="5.2" id="hetero"><span class="secno">5.2. </span><span class="content">Heterogeneous relocation</span><a class="self-link" href="#hetero"></a></h3>
   <p>Consider that <code class="highlight"><span class="n">is_relocatable_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span></code> means <code class="highlight"><span class="n">is_constructible_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="o">&amp;&amp;></span> <span class="n">and</span> <span class="n">is_destructible_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span></code>.
We have access to a heterogeneous <code class="highlight"><span class="n">is_constructible</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Us</span><span class="p">...</span><span class="o">></span></code>.
Should we add a heterogeneous <code class="highlight"><span class="n">is_relocatable_from</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">></span></code>?</p>
   <p>Notice that <code class="highlight"><span class="n">uninitialized_copy</span></code> and <code class="highlight"><span class="n">uninitialized_move</span></code> are already heterogeneous.
Here is what a heterogeneous <code class="highlight"><span class="n">uninitialized_relocate</span></code> would look like.</p>
   <p><small></small></p>
   <small> <pre class="language-c++ highlight"><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">FwdIt</span><span class="p">,</span> <span class="n">class</span> <span class="n">OutIt</span><span class="o">></span>
<span class="kt">void</span> <span class="n">uninitialized_relocate</span><span class="p">(</span><span class="n">FwdIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">FwdIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">OutIt</span> <span class="n">d_first</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">using</span> <span class="n">SrcT</span> <span class="o">=</span> <span class="n">remove_cvref_t</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">)</span><span class="o">></span><span class="p">;</span>
    <span class="n">using</span> <span class="n">DstT</span> <span class="o">=</span> <span class="n">remove_cvref_t</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">d_first</span><span class="p">)</span><span class="o">></span><span class="p">;</span>
    <span class="n">static_assert</span><span class="p">(</span><span class="n">is_relocatable_from_v</span><span class="o">&lt;</span><span class="n">DstT</span><span class="p">,</span> <span class="n">SrcT</span><span class="o">></span><span class="p">);</span>
    <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">is_trivially_relocatable_from_v</span><span class="o">&lt;</span><span class="n">DstT</span><span class="p">,</span> <span class="n">SrcT</span><span class="o">></span><span class="p">)</span> <span class="p">{</span>
        <span class="n">static_assert</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="n">SrcT</span><span class="p">)</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DstT</span><span class="p">));</span>
        <span class="k">if</span> <span class="n">constexpr</span> <span class="p">(</span><span class="n">is_pointer_v</span><span class="o">&lt;</span><span class="n">FwdIt</span><span class="o">></span> <span class="o">&amp;&amp;</span> <span class="n">is_pointer_v</span><span class="o">&lt;</span><span class="n">OutIt</span><span class="o">></span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Trivial relocation + contiguous iterators = memcpy</span>
<span class="c1"></span>            <span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="n">memcpy</span><span class="p">(</span><span class="n">d_first</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">SrcT</span><span class="p">));</span>
            <span class="n">d_first</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">memcpy</span><span class="p">(</span><span class="n">addressof</span><span class="p">(</span><span class="o">*</span><span class="n">d_first</span><span class="p">),</span> <span class="n">addressof</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">),</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">SrcT</span><span class="p">));</span>
                <span class="o">++</span><span class="n">d_first</span><span class="p">;</span> <span class="o">++</span><span class="n">first</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">::</span><span class="n">new</span> <span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">addressof</span><span class="p">(</span><span class="o">*</span><span class="n">d_first</span><span class="p">))</span> <span class="n">DstT</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">));</span>
            <span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">).</span><span class="o">~</span><span class="n">SrcT</span><span class="p">();</span>
            <span class="o">++</span><span class="n">d_first</span><span class="p">;</span> <span class="o">++</span><span class="n">first</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">d_first</span><span class="p">;</span>
<span class="p">}</span>
</pre></small> 
   <p>This implementation could be used to quickly relocate an array of <code class="highlight"><span class="kt">int</span><span class="o">*</span></code> into an array of <code class="highlight"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">></span></code> (but not vice versa). It could also be used to quickly relocate an array of <code class="highlight"><span class="n">T</span></code> into an array of <code class="highlight"><span class="n">tombstone</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span></code>. (The concept of "tombstone optional"
is described in <a data-link-type="biblio" href="#biblio-best">[Best]</a>.)
All we’d need is for somebody to set the value of <code class="highlight"><span class="n">is_trivially_relocatable_from</span></code> appropriately for each pair of types in the program.</p>
   <p>I think this is a very intriguing idea. The detection syntax (<code class="highlight"><span class="n">is_trivially_relocatable_from</span></code>)
is fairly obvious. But I don’t see what the opt-in syntax
would look like on a program-defined class such as <code class="highlight"><span class="n">tombstone</span><span class="o">::</span><span class="n">optional</span></code>.
Let’s leave that problem alone for a few years and see what develops.</p>
   <p>We could conceivably provide the detection trait today,
with deliberately curtailed semantics, e.g.:</p>
   <p><small></small></p>
   <small> <pre class="language-c++ highlight">    <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="p">,</span> <span class="n">class</span> <span class="n">U</span><span class="o">></span>
    <span class="k">struct</span> <span class="nl">is_trivially_relocatable_from</span> <span class="p">:</span> <span class="n">bool_constant</span><span class="o">&lt;</span>
        <span class="n">is_trivially_relocatable_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span> <span class="n">and</span>
        <span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span> <span class="n">remove_cvref_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">>></span>
    <span class="o">></span> <span class="p">{};</span>
    <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="p">,</span> <span class="n">class</span> <span class="n">U</span><span class="o">></span>
    <span class="k">struct</span> <span class="n">is_trivially_relocatable_from</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&amp;></span> <span class="o">:</span> <span class="n">is_trivially_relocatable_from</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">></span> <span class="p">{};</span>
    <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="p">,</span> <span class="n">class</span> <span class="n">U</span><span class="o">></span>
    <span class="k">struct</span> <span class="n">is_trivially_relocatable_from</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&amp;&amp;></span> <span class="o">:</span> <span class="n">is_trivially_relocatable_from</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">></span> <span class="p">{};</span>
</pre></small> 
   <p>plus permission for vendors to extend the trait via partial specializations on
a QoI basis:</p>
   <p><small></small></p>
   <small> <pre class="language-c++ highlight">    <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">></span>
    <span class="k">struct</span> <span class="n">is_trivially_relocatable_from</span><span class="o">&lt;</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span><span class="p">,</span> <span class="n">T</span><span class="o">*></span> <span class="o">:</span> <span class="n">true_type</span> <span class="p">{};</span>
    <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">></span>
    <span class="k">struct</span> <span class="n">is_trivially_relocatable_from</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span><span class="p">,</span> <span class="n">T</span><span class="o">*></span> <span class="o">:</span> <span class="n">true_type</span> <span class="p">{};</span>
    <span class="k">struct</span> <span class="n">is_trivially_relocatable_from</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span><span class="o">></span> <span class="o">:</span> <span class="n">true_type</span> <span class="p">{};</span>
    <span class="c1">// and so on</span>
</pre></small> 
   <p>However, if we do this, we may soon find that programmers are adding specializations
of <code class="highlight"><span class="n">is_trivially_relocatable_from</span></code> to their own programs, because they find it
makes their code run faster. It will become a de-facto customization point, and we will
never be able to "fix it right" for fear of breaking programmers' existing code.</p>
   <p>Therefore, I believe that we should <em>not</em> pursue "heterogeneous" relocation
operations at the present time.</p>
   <p>Note that vendors are already free to optimize heterogeneous operations inside
library algorithms, under the as-if rule. We lack a portable and generic detection
trait, but vendors are presumably well aware of specific special cases that they <em>could</em> detect and optimize today —<wbr>for example, a <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">copy</span></code> from an array of <code class="highlight"><span class="kt">int</span><span class="o">*</span></code> into
an array of <code class="highlight"><span class="k">const</span> <span class="kt">int</span><span class="o">*</span></code>, or from an array of 64-bit <code class="highlight"><span class="kt">long</span></code> into
an array of 64-bit <code class="highlight"><span class="kt">long</span> <span class="kt">long</span></code> (see <a data-link-type="biblio" href="#biblio-tcf">[TCF]</a>).
Today vendors generally choose not to perform these optimizations.</p>
   <h2 class="heading settled" data-level="6" id="acknowledgements"><span class="secno">6. </span><span class="content">Acknowledgements</span><a class="self-link" href="#acknowledgements"></a></h2>
   <p>Thanks to Elias Kosunen and Niall Douglas for their feedback on early drafts of this paper.</p>
   <p>Thanks to Pablo Halpern for <a data-link-type="biblio" href="#biblio-n4158">[N4158]</a>, to which this paper bears a striking and coincidental resemblance —<wbr>including the meaning assigned to the word "trivial," and the library-algorithm approach to avoiding the
problems with "lame duck objects" discussed in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm#Alternative%20move%20designs">the final section</a> of <a data-link-type="biblio" href="#biblio-n1377">[N1377]</a>.</p>
   <p>Many thanks to Matt Godbolt for allowing me to place the prototype implementation on Compiler Explorer Beta
(a.k.a. <a href="https://godbolt.org/g/TA2Xmy">godbolt.org/beta</a>).</p>
   <h2 class="heading settled" id="polls"><span class="content">Appendix A: Straw polls requested</span><a class="self-link" href="#polls"></a></h2>
   <h3 class="heading settled" id="lewg-polls"><span class="content">Polls for LEWG</span><a class="self-link" href="#lewg-polls"></a></h3>
   <table class="def">
    <tbody>
     <tr>
      <th style="width: 70%;">
      <th><strong>SF</strong>
      <th><strong>F</strong>
      <th><strong>N</strong>
      <th><strong>A</strong>
      <th><strong>SA</strong>
     <tr>
      <th><small>The algorithm <code class="highlight"><span class="n">uninitialized_relocate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">d_first</span><span class="p">)</span></code> should be added to the <code class="highlight"><span class="o">&lt;</span><span class="n">memory</span><span class="o">></span></code> header,
as proposed in this paper.</small>
      <th>_
      <th>_
      <th>_
      <th>_
      <th>_
     <tr>
      <th><small>The type trait <code class="highlight"><span class="n">is_relocatable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span></code> (and its <code class="highlight"><span class="n">_v</span></code> version) should be added to the <code class="highlight"><span class="o">&lt;</span><span class="n">type_traits</span><span class="o">></span></code> header, as proposed in this paper.</small>
      <th>_
      <th>_
      <th>_
      <th>_
      <th>_
     <tr>
      <th><small>If <code class="highlight"><span class="n">is_relocatable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span></code> <em>is</em> added, then we should also add <code class="highlight"><span class="n">is_nothrow_relocatable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span></code> (and its <code class="highlight"><span class="n">_v</span></code> version), as proposed in this paper.</small>
      <th>_
      <th>_
      <th>_
      <th>_
      <th>_
     <tr>
      <th><small>The type trait <code class="highlight"><span class="n">is_trivially_relocatable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span></code> (and its <code class="highlight"><span class="n">_v</span></code> version) should be added to the <code class="highlight"><span class="o">&lt;</span><span class="n">type_traits</span><span class="o">></span></code> header, under that exact name, as proposed in this paper.</small>
      <th>_
      <th>_
      <th>_
      <th>_
      <th>_
     <tr>
      <th><small>We approve of a trait with the semantics of <code class="highlight"><span class="n">is_trivially_relocatable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span></code>, but not necessarily under that exact name. (For example, <code class="highlight"><span class="n">is_bitwise_relocatable</span></code>.)</small>
      <th>_
      <th>_
      <th>_
      <th>_
      <th>_
     <tr>
      <th><small>If <code class="highlight"><span class="n">is_trivially_relocatable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span></code> <em>is</em> added, under that exact name, then the type trait <code class="highlight"><span class="n">is_trivially_swappable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span></code> (and its <code class="highlight"><span class="n">_v</span></code> version) should also be added to the <code class="highlight"><span class="o">&lt;</span><span class="n">type_traits</span><span class="o">></span></code> header.</small>
      <th>_
      <th>_
      <th>_
      <th>_
      <th>_
   </table>
   <h3 class="heading settled" id="ewg-polls"><span class="content">Polls for EWG</span><a class="self-link" href="#ewg-polls"></a></h3>
   <table class="def">
    <tbody>
     <tr>
      <th style="width: 70%;">
      <th><strong>SF</strong>
      <th><strong>F</strong>
      <th><strong>N</strong>
      <th><strong>A</strong>
      <th><strong>SA</strong>
     <tr>
      <th><small>We approve of the general idea that user-defined classes should be able to warrant their own trivial relocatability.</small>
      <th>_
      <th>_
      <th>_
      <th>_
      <th>_
     <tr>
      <th><small>We approve of the general idea that user-defined classes which follow the Rule of Zero should inherit the trivial relocatability of their bases and members.</small>
      <th>_
      <th>_
      <th>_
      <th>_
      <th>_
     <tr>
      <th><small>Nobody should be able to warrant the trivial relocatability of <code class="highlight"><span class="k">class</span> <span class="nc">C</span></code> except for <code class="highlight"><span class="k">class</span> <span class="nc">C</span></code> itself (i.e., we do not want to see a customization point analogous to <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">hash</span></code>).</small>
      <th>_
      <th>_
      <th>_
      <th>_
      <th>_
     <tr>
      <th><small>If a trait with the semantics of <code class="highlight"><span class="n">is_trivially_relocatable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span></code> is added to the <code class="highlight"><span class="o">&lt;</span><span class="n">type_traits</span><span class="o">></span></code> header, the programmer should be permitted to specialize it for program-defined types (i.e., we want to see that trait itself become a customization point analogous to <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">hash</span></code>).</small>
      <th>_
      <th>_
      <th>_
      <th>_
      <th>_
     <tr>
      <th><small>A class should be able to warrant its own trivial relocatability via the attribute <code class="highlight"><span class="p">[[</span><span class="n">trivially_relocatable</span><span class="p">]]</span></code>, as proposed in this paper.</small>
      <th>_
      <th>_
      <th>_
      <th>_
      <th>_
     <tr>
      <th><small>A class should be able to warrant its own trivial relocatability via some attribute, but not necessarily under that exact name.</small>
      <th>_
      <th>_
      <th>_
      <th>_
      <th>_
     <tr>
      <th><small>A class should be able to warrant its own trivial relocatability as proposed in this paper, but via a contextual keyword rather than an attribute.</small>
      <th>_
      <th>_
      <th>_
      <th>_
      <th>_
     <tr>
      <th><small>Trivial relocatability should be assumed by default. Classes such as those in <a href="#non-trivial-samples">Appendix C</a> should indicate their non-trivial relocatability via an opt-in mechanism.</small>
      <th>_
      <th>_
      <th>_
      <th>_
      <th>_
     <tr>
      <th><small>To simplify <a href="#sample-conditional">Conditionally trivial relocation</a>, if an attribute with the semantics of <code class="highlight"><span class="p">[[</span><span class="n">trivially_relocatable</span><span class="p">]]</span></code> is added, it should take a boolean argument.</small>
      <th>_
      <th>_
      <th>_
      <th>_
      <th>_
   </table>
   <h2 class="heading settled" id="samples"><span class="content">Appendix B: Sample code</span><a class="self-link" href="#samples"></a></h2>
   <h3 class="heading settled" id="sample-deducing"><span class="content">Defining a trivially relocatable function object</span><a class="self-link" href="#sample-deducing"></a></h3>
   <p>The following sample illustrates <a href="#use2">§2.2 Program-defined types that follow the Rule of Zero</a>. Here <code class="highlight"><span class="n">A</span></code> is a program-defined type
following the Rule of Zero. Because all of its bases and members are warranted as
trivially relocatable, and its move-constructor and destructor are both defaulted,
the compiler concludes that <code class="highlight"><span class="n">A</span></code> itself is trivially relocatable.</p>
<pre class="highlight">    <span class="cp">#include</span> &lt;string><span class="cp"></span>
<span class="cp"></span>    <span class="cp">#include</span> &lt;type_traits><span class="cp"></span>
<span class="cp"></span>
    <span class="c1">// Assume that the library vendor has taken care of this part.</span>
<span class="c1"></span>    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_trivially_relocatable_v</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">></span><span class="p">);</span>

    <span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">t</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">s</span> <span class="o">+</span> <span class="n">t</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_trivially_relocatable_v</span><span class="o">&lt;</span> <span class="n">A</span> <span class="o">></span><span class="p">);</span>
</pre>
   <p>The following sample, involving an implementation-defined closure type,
also illustrates <a href="#use2">§2.2 Program-defined types that follow the Rule of Zero</a>.</p>
<pre class="highlight">    <span class="cp">#include</span> &lt;string><span class="cp"></span>
<span class="cp"></span>    <span class="cp">#include</span> &lt;type_traits><span class="cp"></span>
<span class="cp"></span>
    <span class="c1">// Assume that the library vendor has taken care of this part.</span>
<span class="c1"></span>    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_trivially_relocatable_v</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">></span><span class="p">);</span>

    <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"hello"</span><span class="p">)](</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">s</span> <span class="o">+</span> <span class="n">t</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_trivially_relocatable_v</span><span class="o">&lt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">></span><span class="p">);</span>
</pre>
   <h3 class="heading settled" id="sample-opting-in"><span class="content">Warranting that a user-defined relocation operation is equivalent to <code class="highlight"><span class="n">memcpy</span></code></span><a class="self-link" href="#sample-opting-in"></a></h3>
   <p>The following sample illustrates <a href="#use3">§2.3 Program-defined types with non-defaulted special members</a>. The rules proposed in this paper ensure
that any type with non-trivial user-defined move and destructor operations will be
considered non-trivially relocatable by default.</p>
<pre class="highlight">    <span class="cp">#include</span> &lt;type_traits><span class="cp"></span>
<span class="cp"></span>
    <span class="k">struct</span> <span class="n">C</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">C</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">s</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{}</span>
        <span class="n">C</span><span class="p">(</span><span class="n">C</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">:</span> <span class="n">s</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="n">rhs</span><span class="p">.</span><span class="n">s</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="p">}</span>
        <span class="o">~</span><span class="n">C</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">s</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">static_assert</span><span class="p">(</span><span class="n">not</span> <span class="n">std</span><span class="o">::</span><span class="n">is_trivially_relocatable_v</span><span class="o">&lt;</span> <span class="n">C</span> <span class="o">></span><span class="p">);</span>

    <span class="k">struct</span> <span class="nl">D</span> <span class="p">:</span> <span class="n">C</span> <span class="p">{};</span>

    <span class="k">static_assert</span><span class="p">(</span><span class="n">not</span> <span class="n">std</span><span class="o">::</span><span class="n">is_trivially_relocatable_v</span><span class="o">&lt;</span> <span class="n">D</span> <span class="o">></span><span class="p">);</span>
</pre>
   <p>The programmer may apply the <code class="highlight"><span class="p">[[</span><span class="n">trivially_relocatable</span><span class="p">]]</span></code> attribute to override the compiler’s default
behavior and warrant (under penalty of undefined behavior) that this type is in fact trivially relocatable.</p>
<pre class="highlight">    <span class="cp">#include</span> &lt;type_traits><span class="cp"></span>
<span class="cp"></span>
    <span class="k">struct</span> <span class="p">[[</span><span class="n">trivially_relocatable</span><span class="p">]]</span> <span class="n">E</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">E</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">s</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{}</span>
        <span class="n">E</span><span class="p">(</span><span class="n">C</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">:</span> <span class="n">s</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="n">rhs</span><span class="p">.</span><span class="n">s</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="p">}</span>
        <span class="o">~</span><span class="n">E</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">s</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_trivially_relocatable_v</span><span class="o">&lt;</span> <span class="n">E</span> <span class="o">></span><span class="p">);</span>

    <span class="k">struct</span> <span class="nl">F</span> <span class="p">:</span> <span class="n">E</span> <span class="p">{};</span>

    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_trivially_relocatable_v</span><span class="o">&lt;</span> <span class="n">F</span> <span class="o">></span><span class="p">);</span>
</pre>
   <h3 class="heading settled" id="sample-uninit-relocate"><span class="content">Reference implementation of <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">uninitialized_relocate</span></code></span><a class="self-link" href="#sample-uninit-relocate"></a></h3>
   <p><small></small></p>
   <small> <pre class="highlight"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ForwardIterator</span><span class="o">></span>
<span class="n">ForwardIterator</span> <span class="n">uninitialized_relocate</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">,</span>
                                       <span class="n">ForwardIterator</span> <span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">T</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">ForwardIterator</span><span class="o">>::</span><span class="n">value_type</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">U</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_ref_t</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">))</span><span class="o">></span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">memcpyable</span> <span class="o">=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">></span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_trivially_relocatable_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span><span class="p">);</span>
    <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">both_contiguous</span> <span class="o">=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_pointer_v</span><span class="o">&lt;</span><span class="n">InputIterator</span><span class="o">></span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_pointer_v</span><span class="o">&lt;</span><span class="n">ForwardIterator</span><span class="o">></span><span class="p">);</span>

    <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">memcpyable</span> <span class="o">&amp;&amp;</span> <span class="n">both_contiguous</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">nbytes</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">last</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">first</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nbytes</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">memmove</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">),</span> <span class="n">nbytes</span><span class="p">);</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">memcpyable</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="o">++</span><span class="n">result</span><span class="p">,</span> <span class="o">++</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">memmove</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">),</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">T</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="o">++</span><span class="n">result</span><span class="p">,</span> <span class="o">++</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">::</span><span class="k">new</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*></span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="p">)))</span> <span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">));</span>
            <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></small> 
   <p>The code in the first branch must use <code class="highlight"><span class="n">memmove</span></code>, rather than <code class="highlight"><span class="n">memcpy</span></code>, to preserve the
formally specified behavior in the case that the source range overlaps the destination range.</p>
   <p>The code in the second branch, which performs one <code class="highlight"><span class="n">memmove</span></code> per element, probably
doesn’t have much of a performance benefit, and might be eliminated by library vendors.</p>
   <h3 class="heading settled" id="sample-conditional"><span class="content">Conditionally trivial relocation</span><a class="self-link" href="#sample-conditional"></a></h3>
   <p>We expect, but do not require, that <code class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span></code> should be trivially relocatable
if and only if <code class="highlight"><span class="n">T</span></code> itself is trivially relocatable. We propose no dedicated syntax for conditional <code class="highlight"><span class="p">[[</span><span class="n">trivially_relocatable</span><span class="p">]]</span></code>.</p>
   <p>The following abbreviated implementation shows how to achieve an <code class="highlight"><span class="n">optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span></code> which
has the same trivial-move-constructibility as <code class="highlight"><span class="n">T</span></code>, the same trivial-destructibility
as <code class="highlight"><span class="n">T</span></code>, and the same trivial-relocatability as <code class="highlight"><span class="n">T</span></code>.</p>
   <p><small></small></p>
   <small> <pre class="highlight"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">></span>
<span class="k">class</span> <span class="nc">optional</span> <span class="o">:</span>
    <span class="n">optional_a</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">is_trivially_relocatable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">>></span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">optional_a</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">is_trivially_relocatable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">>>::</span><span class="n">optional_a</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">R</span><span class="o">></span>
<span class="k">class</span> <span class="nc">optional_a</span> <span class="o">:</span>
    <span class="n">optional_b</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">is_trivially_destructible</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span><span class="p">,</span> <span class="n">is_trivially_move_constructible</span><span class="o">&lt;</span><span class="n">T</span><span class="o">>></span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">optional_b</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">is_trivially_destructible</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span><span class="p">,</span>
        <span class="n">is_trivially_move_constructible</span><span class="o">&lt;</span><span class="n">T</span><span class="o">>>::</span><span class="n">optional_b</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">></span>
<span class="k">class</span> [[<span class="nc">trivially_relocatable</span><span class="p">]]</span> <span class="n">optional_a</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> true<span class="o">></span> <span class="o">:</span>
    <span class="n">optional_b</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">is_trivially_destructible</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span><span class="p">,</span> <span class="n">is_trivially_move_constructible</span><span class="o">&lt;</span><span class="n">T</span><span class="o">>></span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">optional_b</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">is_trivially_destructible</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span><span class="p">,</span>
        <span class="n">is_trivially_move_constructible</span><span class="o">&lt;</span><span class="n">T</span><span class="o">>>::</span><span class="n">optional_b</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">D</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">M</span><span class="o">></span>
<span class="k">class</span> <span class="nc">optional_b</span> <span class="p">{</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">dummy_</span><span class="p">;</span>
        <span class="n">T</span> <span class="n">value_</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kt">bool</span> <span class="n">engaged_</span> <span class="o">=</span> false<span class="p">;</span>

    <span class="n">optional_b</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">optional_b</span><span class="p">(</span><span class="n">inplace_t</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="n">args</span><span class="p">...)</span> <span class="o">:</span>
        <span class="n">engaged_</span><span class="p">(</span>true<span class="p">),</span> <span class="n">value_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">></span><span class="p">(</span><span class="n">args</span><span class="p">)...)</span> <span class="p">{}</span>
    <span class="n">optional_b</span><span class="p">(</span><span class="n">optional_b</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">engaged_</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">engaged_</span> <span class="o">=</span> true<span class="p">;</span>
            <span class="o">::</span><span class="k">new</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="n">value_</span><span class="p">))</span> <span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">value_</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">optional_b</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">engaged_</span><span class="p">)</span> <span class="n">value_</span><span class="p">.</span><span class="o">~</span><span class="n">T</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">></span>
<span class="k">class</span> <span class="nc">optional_b</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> false<span class="p">,</span> true<span class="o">></span> <span class="p">{</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">dummy_</span><span class="p">;</span>
        <span class="n">T</span> <span class="n">value_</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kt">bool</span> <span class="n">engaged_</span> <span class="o">=</span> false<span class="p">;</span>

    <span class="n">optional_b</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">optional_b</span><span class="p">(</span><span class="n">inplace_t</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="n">args</span><span class="p">...)</span> <span class="o">:</span>
        <span class="n">engaged_</span><span class="p">(</span>true<span class="p">),</span> <span class="n">value_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">></span><span class="p">(</span><span class="n">args</span><span class="p">)...)</span> <span class="p">{}</span>
    <span class="n">optional_b</span><span class="p">(</span><span class="n">optional_b</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="o">~</span><span class="n">optional_b</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">engaged_</span><span class="p">)</span> <span class="n">value_</span><span class="p">.</span><span class="o">~</span><span class="n">T</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">></span>
<span class="k">class</span> <span class="nc">optional_b</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> true<span class="p">,</span> false<span class="o">></span> <span class="p">{</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">dummy_</span><span class="p">;</span>
        <span class="n">T</span> <span class="n">value_</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kt">bool</span> <span class="n">engaged_</span> <span class="o">=</span> false<span class="p">;</span>

    <span class="n">optional_b</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">optional_b</span><span class="p">(</span><span class="n">inplace_t</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="n">args</span><span class="p">...)</span> <span class="o">:</span>
        <span class="n">engaged_</span><span class="p">(</span>true<span class="p">),</span> <span class="n">value_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">></span><span class="p">(</span><span class="n">args</span><span class="p">)...)</span> <span class="p">{}</span>
    <span class="n">optional_b</span><span class="p">(</span><span class="n">optional_b</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">engaged_</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">engaged_</span> <span class="o">=</span> true<span class="p">;</span>
            <span class="o">::</span><span class="k">new</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="n">value_</span><span class="p">))</span> <span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">value_</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">optional_b</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">></span>
<span class="k">class</span> <span class="nc">optional_b</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> true<span class="p">,</span> true<span class="o">></span> <span class="p">{</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">dummy_</span><span class="p">;</span>
        <span class="n">T</span> <span class="n">value_</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kt">bool</span> <span class="n">engaged_</span> <span class="o">=</span> false<span class="p">;</span>

    <span class="n">optional_b</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">optional_b</span><span class="p">(</span><span class="n">inplace_t</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="n">args</span><span class="p">...)</span> <span class="o">:</span>
        <span class="n">engaged_</span><span class="p">(</span>true<span class="p">),</span> <span class="n">value_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">></span><span class="p">(</span><span class="n">args</span><span class="p">)...)</span> <span class="p">{}</span>

    <span class="n">optional_b</span><span class="p">(</span><span class="n">optional_b</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="o">~</span><span class="n">optional_b</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>
</pre></small> 
   <h2 class="heading settled" id="non-trivial-samples"><span class="content">Appendix C: Examples of non-trivially relocatable class types</span><a class="self-link" href="#non-trivial-samples"></a></h2>
   <h3 class="heading settled" id="non-trivial-sample-string"><span class="content">Class contains pointer to self</span><a class="self-link" href="#non-trivial-sample-string"></a></h3>
   <p>This fictional <code class="highlight"><span class="n">short_string</span></code> illustrates a mechanism that can apply
to any small-buffer-optimized class. <a data-link-type="biblio" href="#biblio-libcxxfunction">libc++'s std::function</a> uses this mechanism (on a 24-byte buffer) and is thus not trivially relocatable.</p>
   <p>However, different mechanisms for small-buffer optimization exist. <a data-link-type="biblio" href="#biblio-libcxxany">libc++'s std::any</a> also achieves small-buffer optimization
on a 24-byte buffer, without sacrificing trivial relocatability.</p>
   <p><small></small></p>
   <small> <pre class="highlight"><span class="k">struct</span> <span class="n">short_string</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">data_</span> <span class="o">=</span> <span class="n">buffer_</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">size_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buffer_</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>

    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">data</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data_</span><span class="p">;</span> <span class="p">}</span>

    <span class="n">short_string</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">short_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">size_</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">size_</span> <span class="o">&lt;</span> <span class="k">sizeof</span> <span class="n">buffer_</span><span class="p">)</span>
            <span class="n">strcpy</span><span class="p">(</span><span class="n">buffer_</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">data_</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">short_string</span><span class="p">(</span><span class="n">short_string</span><span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">data_</span> <span class="o">==</span> <span class="n">s</span><span class="p">.</span><span class="n">buffer_</span><span class="p">)</span>
            <span class="n">data_</span> <span class="o">=</span> <span class="n">buffer_</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">s</span><span class="p">.</span><span class="n">data_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">short_string</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data_</span> <span class="o">!=</span> <span class="n">buffer_</span><span class="p">)</span>
            <span class="n">free</span><span class="p">(</span><span class="n">data_</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></small> 
   <h3 class="heading settled" id="non-trivial-sample-offset-ptr"><span class="content">Class invariant depends on <code class="highlight"><span class="k">this</span></code></span><a class="self-link" href="#non-trivial-sample-offset-ptr"></a></h3>
   <p>The <code class="highlight"><span class="n">offset_ptr</span></code> provided by <a data-link-type="biblio" href="#biblio-boostinterprocess">[Boost.Interprocess]</a> is an example of this category.</p>
   <p><small></small></p>
   <small> <pre class="highlight"><span class="k">struct</span> <span class="n">offset_ptr</span> <span class="p">{</span>
    <span class="kt">uintptr_t</span> <span class="n">value_</span><span class="p">;</span>

    <span class="kt">uintptr_t</span> <span class="nf">here</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="kt">uintptr_t</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
    <span class="kt">uintptr_t</span> <span class="nf">distance_to</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="kt">uintptr_t</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="n">here</span><span class="p">();</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="o">*</span><span class="nf">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">here</span><span class="p">()</span> <span class="o">+</span> <span class="n">value_</span><span class="p">);</span> <span class="p">}</span>

    <span class="n">offset_ptr</span><span class="p">()</span> <span class="o">:</span> <span class="n">value_</span><span class="p">(</span><span class="n">distance_to</span><span class="p">(</span><span class="k">nullptr</span><span class="p">))</span> <span class="p">{}</span>
    <span class="n">offset_ptr</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="o">:</span> <span class="n">value_</span><span class="p">(</span><span class="n">distance_to</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{}</span>
    <span class="n">offset_ptr</span><span class="p">(</span><span class="k">const</span> <span class="n">offset_ptr</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">:</span> <span class="n">value_</span><span class="p">(</span><span class="n">distance_to</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">get</span><span class="p">()))</span> <span class="p">{}</span>
    <span class="n">offset_ptr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">offset_ptr</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">value_</span> <span class="o">=</span> <span class="n">distance_to</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">offset_ptr</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>
</pre></small> 
   <h3 class="heading settled" id="non-trivial-sample-registry"><span class="content">Program invariant depends on <code class="highlight"><span class="k">this</span></code></span><a class="self-link" href="#non-trivial-sample-registry"></a></h3>
   <p>This example was suggested by Mingxin Wang.
In the following snippet, <code class="highlight"><span class="k">struct</span> <span class="n">Widget</span></code> is relocatable, but not
trivially relocatable, because the relocation operation of destroying a <code class="highlight"><span class="n">Widget</span></code> at point A
and constructing a new <code class="highlight"><span class="n">Widget</span></code> at point B has behavior that is observably different
from a simple <code class="highlight"><span class="n">memcpy</span></code>.</p>
   <p><small></small></p>
   <small> <pre class="highlight"><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">void</span> <span class="o">*></span> <span class="n">registry</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">registered_object</span> <span class="p">{</span>
    <span class="n">registered_object</span><span class="p">()</span> <span class="p">{</span> <span class="n">registry</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">registered_object</span><span class="p">(</span><span class="n">registered_object</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">registered_object</span><span class="p">(</span><span class="k">const</span> <span class="n">registered_object</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">registered_object</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">registered_object</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">registered_object</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">registered_object</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="o">~</span><span class="n">registered_object</span><span class="p">()</span> <span class="p">{</span> <span class="n">registry</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Widget</span> <span class="p">:</span> <span class="n">registered_object</span> <span class="p">{};</span>
</pre></small> 
   <h2 class="heading settled" id="implementation"><span class="content">Appendix D: Implementation and benchmarks</span><a class="self-link" href="#implementation"></a></h2>
   <p>A prototype Clang/libc++ implementation is at</p>
   <ul>
    <li data-md="">
     <p><a href="https://github.com/Quuxplusone/clang/tree/trivially-relocatable">github.com/Quuxplusone/clang/tree/trivially-relocatable</a></p>
    <li data-md="">
     <p><a href="https://github.com/Quuxplusone/libcxx/tree/trivially-relocatable">github.com/Quuxplusone/libcxx/tree/trivially-relocatable</a></p>
   </ul>
   <p class="issue" id="issue-f957a4d8"><a class="self-link" href="#issue-f957a4d8"></a> no benchmarks yet</p>
  </main>
<script>
(function() {
  "use strict";
  var collapseSidebarText = '<span aria-hidden="true">←</span> '
                          + '<span>Collapse Sidebar</span>';
  var expandSidebarText   = '<span aria-hidden="true">→</span> '
                          + '<span>Pop Out Sidebar</span>';
  var tocJumpText         = '<span aria-hidden="true">↑</span> '
                          + '<span>Jump to Table of Contents</span>';

  var sidebarMedia = window.matchMedia('screen and (min-width: 78em)');
  var autoToggle   = function(e){ toggleSidebar(e.matches) };
  if(sidebarMedia.addListener) {
    sidebarMedia.addListener(autoToggle);
  }

  function toggleSidebar(on) {
    if (on == undefined) {
      on = !document.body.classList.contains('toc-sidebar');
    }

    /* Don’t scroll to compensate for the ToC if we’re above it already. */
    var headY = 0;
    var head = document.querySelector('.head');
    if (head) {
      // terrible approx of "top of ToC"
      headY += head.offsetTop + head.offsetHeight;
    }
    var skipScroll = window.scrollY < headY;

    var toggle = document.getElementById('toc-toggle');
    var tocNav = document.getElementById('toc');
    if (on) {
      var tocHeight = tocNav.offsetHeight;
      document.body.classList.add('toc-sidebar');
      document.body.classList.remove('toc-inline');
      toggle.innerHTML = collapseSidebarText;
      if (!skipScroll) {
        window.scrollBy(0, 0 - tocHeight);
      }
      tocNav.focus();
      sidebarMedia.addListener(autoToggle); // auto-collapse when out of room
    }
    else {
      document.body.classList.add('toc-inline');
      document.body.classList.remove('toc-sidebar');
      toggle.innerHTML = expandSidebarText;
      if (!skipScroll) {
        window.scrollBy(0, tocNav.offsetHeight);
      }
      if (toggle.matches(':hover')) {
        /* Unfocus button when not using keyboard navigation,
           because I don’t know where else to send the focus. */
        toggle.blur();
      }
    }
  }

  function createSidebarToggle() {
    /* Create the sidebar toggle in JS; it shouldn’t exist when JS is off. */
    var toggle = document.createElement('a');
      /* This should probably be a button, but appearance isn’t standards-track.*/
    toggle.id = 'toc-toggle';
    toggle.class = 'toc-toggle';
    toggle.href = '#toc';
    toggle.innerHTML = collapseSidebarText;

    sidebarMedia.addListener(autoToggle);
    var toggler = function(e) {
      e.preventDefault();
      sidebarMedia.removeListener(autoToggle); // persist explicit off states
      toggleSidebar();
      return false;
    }
    toggle.addEventListener('click', toggler, false);


    /* Get <nav id=toc-nav>, or make it if we don’t have one. */
    var tocNav = document.getElementById('toc-nav');
    if (!tocNav) {
      tocNav = document.createElement('p');
      tocNav.id = 'toc-nav';
      /* Prepend for better keyboard navigation */
      document.body.insertBefore(tocNav, document.body.firstChild);
    }
    /* While we’re at it, make sure we have a Jump to Toc link. */
    var tocJump = document.getElementById('toc-jump');
    if (!tocJump) {
      tocJump = document.createElement('a');
      tocJump.id = 'toc-jump';
      tocJump.href = '#toc';
      tocJump.innerHTML = tocJumpText;
      tocNav.appendChild(tocJump);
    }

    tocNav.appendChild(toggle);
  }

  var toc = document.getElementById('toc');
  if (toc) {
    createSidebarToggle();
    toggleSidebar(sidebarMedia.matches);

    /* If the sidebar has been manually opened and is currently overlaying the text
       (window too small for the MQ to add the margin to body),
       then auto-close the sidebar once you click on something in there. */
    toc.addEventListener('click', function(e) {
      if(e.target.tagName.toLowerCase() == "a" && document.body.classList.contains('toc-sidebar') && !sidebarMedia.matches) {
        toggleSidebar(false);
      }
    }, false);
  }
  else {
    console.warn("Can’t find Table of Contents. Please use <nav id='toc'> around the ToC.");
  }

  /* Wrap tables in case they overflow */
  var tables = document.querySelectorAll(':not(.overlarge) > table.data, :not(.overlarge) > table.index');
  var numTables = tables.length;
  for (var i = 0; i < numTables; i++) {
    var table = tables[i];
    var wrapper = document.createElement('div');
    wrapper.className = 'overlarge';
    table.parentNode.insertBefore(wrapper, table);
    wrapper.appendChild(table);
  }

})();
</script>
  <h2 class="no-num no-ref heading settled" id="index"><span class="content">Index</span><a class="self-link" href="#index"></a></h2>
  <h3 class="no-num no-ref heading settled" id="index-defined-here"><span class="content">Terms defined by this specification</span><a class="self-link" href="#index-defined-here"></a></h3>
  <ul class="index">
   <li><a href="#abstract-opdef-relocation-operation">relocation operation</a><span>, in §4.1</span>
   <li><a href="#abstract-opdef-trivially-relocatable">trivially relocatable</a><span>, in §4.4</span>
  </ul>
  <h2 class="no-num no-ref heading settled" id="references"><span class="content">References</span><a class="self-link" href="#references"></a></h2>
  <h3 class="no-num no-ref heading settled" id="normative"><span class="content">Normative References</span><a class="self-link" href="#normative"></a></h3>
  <dl>
   <dt id="biblio-basictypes">[BASIC.TYPES]
   <dd><a href="http://eel.is/c++draft/basic.types#2">N4750, [basic.types] clauses 2, 3, and 9</a>. May 2018. URL: <a href="http://eel.is/c++draft/basic.types#2">http://eel.is/c++draft/basic.types#2</a>
   <dt id="biblio-cwg1746">[CWG1746]
   <dd>Walter Brown. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1746">Are volatile scalar types trivially copyable?</a>. September 2013–January 2014. URL: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1746">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1746</a>
   <dt id="biblio-cwg2094">[CWG2094]
   <dd>Daveed Vandevoorde. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#2094">Trivial copy/move constructor for class with volatile member</a>. March 2015–June 2016. URL: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#2094">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#2094</a>
   <dt id="biblio-cwg496">[CWG496]
   <dd>John Maddock. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#496">Is a volatile-qualified type really a POD?</a>. December 2004–October 2012. URL: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#496">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#496</a>
   <dt id="biblio-lwg2139">[LWG2139]
   <dd>Loïc Joly. <a href="https://cplusplus.github.io/LWG/issue2139">What is a user-defined type?</a>. March 2012–June 2018. URL: <a href="https://cplusplus.github.io/LWG/issue2139">https://cplusplus.github.io/LWG/issue2139</a>
   <dt id="biblio-lwg3119">[LWG3119]
   <dd>Hubert Tong. <a href="https://cplusplus.github.io/LWG/issue3119">Program-definedness of closure types</a>. June 2018—. URL: <a href="https://cplusplus.github.io/LWG/issue3119">https://cplusplus.github.io/LWG/issue3119</a>
   <dt id="biblio-n4750">[N4750]
   <dd>ISO/IEC JTC1/SC22/WG21 - The C++ Standards Committee; Richard Smith. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4750.pdf">N4750: Working Draft, Standard for Programming Language C++</a>. May 2018. URL: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4750.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4750.pdf</a>
  </dl>
  <h3 class="no-num no-ref heading settled" id="informative"><span class="content">Informative References</span><a class="self-link" href="#informative"></a></h3>
  <dl>
   <dt id="biblio-bench">[Bench]
   <dd>Arthur O'Dwyer. <a href="https://github.com/Quuxplusone/from-scratch/blob/095b246d/cppnow2018/benchmark-relocatable.cc">Benchmark code from "The Best Type Traits C++ Doesn't Have"</a>. April 2018. URL: <a href="https://github.com/Quuxplusone/from-scratch/blob/095b246d/cppnow2018/benchmark-relocatable.cc">https://github.com/Quuxplusone/from-scratch/blob/095b246d/cppnow2018/benchmark-relocatable.cc</a>
   <dt id="biblio-best">[Best]
   <dd>Arthur O'Dwyer. <a href="https://www.youtube.com/watch?v=MWBfmmg8-Yo">The Best Type Traits C++ Doesn't Have (video)</a>. April 2018. URL: <a href="https://www.youtube.com/watch?v=MWBfmmg8-Yo">https://www.youtube.com/watch?v=MWBfmmg8-Yo</a>
   <dt id="biblio-boostinterprocess">[Boost.Interprocess]
   <dd>Ion Gaztañaga. <a href="https://www.boost.org/doc/libs/1_67_0/doc/html/interprocess/offset_ptr.html">Mapping Address Independent Pointer: offset_ptr</a>. 2005. URL: <a href="https://www.boost.org/doc/libs/1_67_0/doc/html/interprocess/offset_ptr.html">https://www.boost.org/doc/libs/1_67_0/doc/html/interprocess/offset_ptr.html</a>
   <dt id="biblio-contra">[Contra]
   <dd>Arthur O'Dwyer. <a href="https://quuxplusone.github.io/blog/2018/04/15/built-in-library-types/">Contra built-in library types</a>. April 2018. URL: <a href="https://quuxplusone.github.io/blog/2018/04/15/built-in-library-types/">https://quuxplusone.github.io/blog/2018/04/15/built-in-library-types/</a>
   <dt id="biblio-libcxxany">[LibcxxAny]
   <dd>Eric Fiselier. <a href="https://github.com/llvm-mirror/libcxx/blob/8fdc4918/include/any#L389-L394">libc++ implementation of std::any (trivially relocatable)</a>. July 2016. URL: <a href="https://github.com/llvm-mirror/libcxx/blob/8fdc4918/include/any#L389-L394">https://github.com/llvm-mirror/libcxx/blob/8fdc4918/include/any#L389-L394</a>
   <dt id="biblio-libcxxfunction">[LibcxxFunction]
   <dd>Howard Hinnant et al. <a href="https://github.com/llvm-mirror/libcxx/blob/4e7ffcaa/include/functional#L1719-L1734">libc++ implementation of std::function (non-trivially relocatable)</a>. URL: <a href="https://github.com/llvm-mirror/libcxx/blob/4e7ffcaa/include/functional#L1719-L1734">https://github.com/llvm-mirror/libcxx/blob/4e7ffcaa/include/functional#L1719-L1734</a>
   <dt id="biblio-libstdcxxfunction">[LibstdcxxFunction]
   <dd>Doug Gregor et al. <a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/std_function.h">libstdc++ implementation of std::function (trivially relocatable)</a>. URL: <a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/std_function.h">https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/std_function.h</a>
   <dt id="biblio-n1377">[N1377]
   <dd>Howard Hinnant; Peter Dimov; Dave Abrahams. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377: A Proposal to Add Move Semantics Support to the C++ Language</a>. September 2002. URL: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm</a>
   <dt id="biblio-n4158">[N4158]
   <dd>Pablo Halpern. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4158.pdf">N4158: Destructive Move (Rev 1)</a>. October 2014. URL: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4158.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4158.pdf</a>
   <dt id="biblio-sane">[Sane]
   <dd>Arthur O'Dwyer. <a href="https://quuxplusone.github.io/blog/2018/07/06/thoughts-on-sanely-move-assignable/">Thoughts on "sanely move-assignable"</a>. July 2018. URL: <a href="https://quuxplusone.github.io/blog/2018/07/06/thoughts-on-sanely-move-assignable/">https://quuxplusone.github.io/blog/2018/07/06/thoughts-on-sanely-move-assignable/</a>
   <dt id="biblio-subobjects">[Subobjects]
   <dd>Arthur O'Dwyer. <a href="https://quuxplusone.github.io/blog/2018/07/13/trivially-copyable-corner-cases/">When is a trivially copyable object not trivially copyable?</a>. July 2018. URL: <a href="https://quuxplusone.github.io/blog/2018/07/13/trivially-copyable-corner-cases/">https://quuxplusone.github.io/blog/2018/07/13/trivially-copyable-corner-cases/</a>
   <dt id="biblio-tcf">[TCF]
   <dd>Arthur O'Dwyer. <a href="https://quuxplusone.github.io/blog/2018/07/03/trivially-constructible-from/">Trivially-constructible-from</a>. July 2018. URL: <a href="https://quuxplusone.github.io/blog/2018/07/03/trivially-constructible-from/">https://quuxplusone.github.io/blog/2018/07/03/trivially-constructible-from/</a>
   <dt id="biblio-wang">[Wang]
   <dd>Mingxin Wang. <a href="https://groups.google.com/a/isocpp.org/d/msg/std-proposals/HGCHVSRwSMk/k7Ir-rmxBgAJ">Better Performance in Polymorphic Programming: Trivially Swappable</a>. June 2018. URL: <a href="https://groups.google.com/a/isocpp.org/d/msg/std-proposals/HGCHVSRwSMk/k7Ir-rmxBgAJ">https://groups.google.com/a/isocpp.org/d/msg/std-proposals/HGCHVSRwSMk/k7Ir-rmxBgAJ</a>
  </dl>
  <h2 class="no-num no-ref heading settled" id="issues-index"><span class="content">Issues Index</span><a class="self-link" href="#issues-index"></a></h2>
  <div style="counter-reset:issue">
   <div class="issue"> [definitions] is probably the wrong place for the core-language definition of "relocation operation"<a href="#issue-75ffe201"> ↵ </a></div>
   <div class="issue"> this definition of "relocation operation" is not good<a href="#issue-7c86f5f7"> ↵ </a></div>
   <div class="issue"> Where in the Standard should we place the definition of "trivially relocatable"?<a href="#issue-ffbbd33c"> ↵ </a></div>
   <div class="issue"> Must we also say that the relevant move constructor (resp. copy constructor) must be public and unambiguous?<a href="#issue-a0d45ced"> ↵ </a></div>
   <div class="issue">
     Consider the following test case—<wbr>
<pre class="highlight">    <span class="k">struct</span> <span class="n">M</span> <span class="p">{</span>
        <span class="n">M</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">M</span><span class="p">(</span><span class="n">M</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="n">puts</span><span class="p">(</span><span class="s">"evil"</span><span class="p">);</span> <span class="p">}</span>
        <span class="n">M</span><span class="p">(</span><span class="k">const</span> <span class="n">M</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">struct</span> <span class="n">T</span> <span class="p">{</span>
        <span class="k">mutable</span> <span class="n">M</span> <span class="n">m</span><span class="p">;</span>
        <span class="o">~</span><span class="n">T</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">static_assert</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">is_trivially_relocatable_v</span><span class="o">&lt;</span><span class="n">M</span><span class="o">></span> <span class="p">);</span>
    <span class="k">static_assert</span><span class="p">(</span> <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_trivially_relocatable_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">></span> <span class="p">);</span>
</pre>
    The declaration <code class="highlight"><span class="n">M</span> <span class="nf">m2</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m</span><span class="p">));</span></code> causes a call to the trivial, defaulted copy constructor <code class="highlight"><span class="n">M</span><span class="p">(</span><span class="k">const</span> <span class="n">M</span><span class="o">&amp;</span><span class="p">)</span></code>, and <code class="highlight"><span class="n">M</span></code> is trivially destructible as well, so we would like <code class="highlight"><span class="n">M</span></code> to be trivially relocatable. But the declaration <code class="highlight"><span class="n">T</span> <span class="nf">t2</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t</span><span class="p">));</span></code> surprisingly causes a call to the user-provided <code class="highlight"><span class="n">M</span><span class="p">(</span><span class="n">M</span><span class="o">&amp;</span><span class="p">)</span></code>, so <code class="highlight"><span class="n">T</span></code> cannot possibly be trivially
relocatable. It may be overly conservative of us to ban <code class="highlight"><span class="k">mutable</span></code> members, but at least we know it is <em>sufficiently</em> conservative. As always, the programmer may explicitly override the compiler’s judgment by declaring <code class="highlight"><span class="n">T</span></code> as <code class="highlight"><span class="p">[[</span><span class="n">trivially_relocatable</span><span class="p">]]</span></code>. <a href="#issue-97d92dd0"> ↵ </a>
   </div>
   <div class="issue"> no benchmarks yet<a href="#issue-f957a4d8"> ↵ </a></div>
  </div>
  <aside class="dfn-panel" data-for="abstract-opdef-relocation-operation">
   <b><a href="#abstract-opdef-relocation-operation">#abstract-opdef-relocation-operation</a></b><b>Referenced in:</b>
   <ul>
    <li><a href="#ref-for-abstract-opdef-relocation-operation">4.4. Trivially relocatable type</a>
   </ul>
  </aside>
  <aside class="dfn-panel" data-for="abstract-opdef-trivially-relocatable">
   <b><a href="#abstract-opdef-trivially-relocatable">#abstract-opdef-trivially-relocatable</a></b><b>Referenced in:</b>
   <ul>
    <li><a href="#ref-for-abstract-opdef-trivially-relocatable">1. Introduction and motivation</a>
    <li><a href="#ref-for-abstract-opdef-trivially-relocatable①">4.6. Type traits is_relocatable etc.</a>
   </ul>
  </aside>
<script>/* script-dfn-panel */

document.body.addEventListener("click", function(e) {
    var queryAll = function(sel) { return [].slice.call(document.querySelectorAll(sel)); }
    // Find the dfn element or panel, if any, that was clicked on.
    var el = e.target;
    var target;
    var hitALink = false;
    while(el.parentElement) {
        if(el.tagName == "A") {
            // Clicking on a link in a <dfn> shouldn't summon the panel
            hitALink = true;
        }
        if(el.classList.contains("dfn-paneled")) {
            target = "dfn";
            break;
        }
        if(el.classList.contains("dfn-panel")) {
            target = "dfn-panel";
            break;
        }
        el = el.parentElement;
    }
    if(target != "dfn-panel") {
        // Turn off any currently "on" or "activated" panels.
        queryAll(".dfn-panel.on, .dfn-panel.activated").forEach(function(el){
            el.classList.remove("on");
            el.classList.remove("activated");
        });
    }
    if(target == "dfn" && !hitALink) {
        // open the panel
        var dfnPanel = document.querySelector(".dfn-panel[data-for='" + el.id + "']");
        if(dfnPanel) {
            dfnPanel.classList.add("on");
            var rect = el.getBoundingClientRect();
            dfnPanel.style.left = window.scrollX + rect.right + 5 + "px";
            dfnPanel.style.top = window.scrollY + rect.top + "px";
            var panelRect = dfnPanel.getBoundingClientRect();
            var panelWidth = panelRect.right - panelRect.left;
            if(panelRect.right > document.body.scrollWidth && (rect.left - (panelWidth + 5)) > 0) {
                // Reposition, because the panel is overflowing
                dfnPanel.style.left = window.scrollX + rect.left - (panelWidth + 5) + "px";
            }
        } else {
            console.log("Couldn't find .dfn-panel[data-for='" + el.id + "']");
        }
    } else if(target == "dfn-panel") {
        // Switch it to "activated" state, which pins it.
        el.classList.add("activated");
        el.style.left = null;
        el.style.top = null;
    }

});
</script>